<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Polymarket Opportunity Scanner</title>
<style>
*{margin:0;padding:0;box-sizing:border-box}
:root{
--bg:#0a0b0f;--card:#12141c;--card-hover:#181b26;--border:#1e2130;
--text:#e4e6f0;--text-dim:#8890a8;--text-muted:#555a70;
--green:#00d68f;--green-dim:#00d68f33;--red:#ff4d6a;--red-dim:#ff4d6a33;
--blue:#4d8ef7;--orange:#f59e0b;--purple:#a855f7;--cyan:#22d3ee;--yellow:#eab308;
--accent:#4d8ef7;
}
body{font-family:-apple-system,BlinkMacSystemFont,'Segoe UI',Roboto,sans-serif;background:var(--bg);color:var(--text);line-height:1.5;min-height:100vh}
a{color:var(--accent);text-decoration:none}
a:hover{text-decoration:underline}

/* Header */
.header{padding:24px 32px;border-bottom:1px solid var(--border);display:flex;align-items:center;justify-content:space-between;flex-wrap:wrap;gap:16px}
.header h1{font-size:24px;font-weight:700;display:flex;align-items:center;gap:10px}
.header h1 span{font-size:28px}
.header-meta{display:flex;align-items:center;gap:16px;font-size:13px;color:var(--text-dim)}
.live-dot{width:8px;height:8px;border-radius:50%;background:var(--green);display:inline-block;animation:pulse 2s infinite}
@keyframes pulse{0%,100%{opacity:1}50%{opacity:.4}}
.status-badge{padding:4px 10px;border-radius:12px;font-size:11px;font-weight:600;background:var(--green-dim);color:var(--green)}

/* Dashboard */
.dashboard{display:grid;grid-template-columns:repeat(auto-fit,minmax(200px,1fr));gap:16px;padding:24px 32px;border-bottom:1px solid var(--border)}
.dash-card{background:var(--card);border:1px solid var(--border);border-radius:12px;padding:20px}
.dash-card .label{font-size:12px;color:var(--text-dim);text-transform:uppercase;letter-spacing:.5px;margin-bottom:6px}
.dash-card .value{font-size:28px;font-weight:700}
.dash-card .sub{font-size:13px;color:var(--text-dim);margin-top:4px}
.dash-card.highlight{border-color:var(--green);background:linear-gradient(135deg,#00d68f08,#00d68f03)}
.dash-card .value.green{color:var(--green)}

/* Category chart */
.cat-chart{display:flex;gap:8px;flex-wrap:wrap;margin-top:10px}
.cat-dot{display:flex;align-items:center;gap:5px;font-size:12px;color:var(--text-dim)}
.cat-dot i{width:10px;height:10px;border-radius:50%;display:inline-block}

/* Controls */
.controls{padding:16px 32px;display:flex;gap:12px;flex-wrap:wrap;align-items:center;border-bottom:1px solid var(--border)}
.search-box{flex:1;min-width:200px;max-width:400px;padding:10px 16px;border-radius:10px;border:1px solid var(--border);background:var(--card);color:var(--text);font-size:14px;outline:none}
.search-box:focus{border-color:var(--accent)}
.search-box::placeholder{color:var(--text-muted)}
select,.btn{padding:8px 14px;border-radius:8px;border:1px solid var(--border);background:var(--card);color:var(--text);font-size:13px;cursor:pointer;outline:none}
select:hover,.btn:hover{border-color:var(--accent)}
.btn.active{background:var(--accent);border-color:var(--accent);color:#fff}
.filter-group{display:flex;gap:6px;flex-wrap:wrap}

/* Grid */
.grid{padding:24px 32px;display:grid;grid-template-columns:repeat(auto-fill,minmax(380px,1fr));gap:16px}
@media(max-width:480px){.grid{grid-template-columns:1fr;padding:16px}}

/* Card */
.card{background:var(--card);border:1px solid var(--border);border-radius:14px;padding:20px;cursor:pointer;transition:all .2s;position:relative;overflow:hidden}
.card:hover{border-color:var(--accent);background:var(--card-hover);transform:translateY(-2px)}
.card-top{display:flex;justify-content:space-between;align-items:flex-start;gap:12px;margin-bottom:12px}
.card-title{font-size:15px;font-weight:600;line-height:1.4;flex:1}
.card-edge{font-size:22px;font-weight:700;white-space:nowrap}
.card-edge.pos{color:var(--green)}
.card-edge.neg{color:var(--red)}
.card-meta{display:flex;gap:8px;flex-wrap:wrap;margin-bottom:12px}
.tag{padding:3px 8px;border-radius:6px;font-size:11px;font-weight:600;text-transform:uppercase;letter-spacing:.3px}
.tag-politics{background:#4d8ef722;color:var(--blue)}
.tag-crypto{background:#f59e0b22;color:var(--orange)}
.tag-sports{background:#00d68f22;color:var(--green)}
.tag-culture{background:#a855f722;color:var(--purple)}
.tag-tech{background:#22d3ee22;color:var(--cyan)}
.tag-economy{background:#eab30822;color:var(--yellow)}
.tag-geopolitics{background:#ff4d6a22;color:var(--red)}
.confidence{font-size:12px}
.liquidity{font-size:12px;color:var(--text-dim)}
.card-prices{display:flex;gap:16px;margin-bottom:10px;font-size:13px}
.price-group{display:flex;flex-direction:column;gap:2px}
.price-label{color:var(--text-muted);font-size:11px;text-transform:uppercase}
.price-val{font-weight:600}
.card-bar{height:4px;border-radius:2px;background:var(--border);margin-bottom:10px;overflow:hidden}
.card-bar-fill{height:100%;border-radius:2px;transition:width .3s}
.card-bottom{display:flex;justify-content:space-between;align-items:center;font-size:12px;color:var(--text-dim)}
.card-resolution{display:flex;align-items:center;gap:4px}

/* Modal */
.modal-overlay{position:fixed;inset:0;background:rgba(0,0,0,.7);z-index:100;display:none;align-items:center;justify-content:center;padding:20px;backdrop-filter:blur(4px)}
.modal-overlay.open{display:flex}
.modal{background:var(--card);border:1px solid var(--border);border-radius:16px;max-width:720px;width:100%;max-height:90vh;overflow-y:auto;padding:32px;position:relative}
.modal-close{position:absolute;top:16px;right:16px;background:none;border:none;color:var(--text-dim);font-size:24px;cursor:pointer;padding:4px}
.modal-close:hover{color:var(--text)}
.modal h2{font-size:20px;font-weight:700;margin-bottom:16px;padding-right:32px;line-height:1.4}
.modal-section{margin-bottom:24px}
.modal-section h3{font-size:14px;font-weight:600;text-transform:uppercase;letter-spacing:.5px;color:var(--text-dim);margin-bottom:10px;display:flex;align-items:center;gap:8px}
.modal-prices{display:grid;grid-template-columns:repeat(3,1fr);gap:16px}
.modal-price-box{background:var(--bg);border-radius:10px;padding:14px;text-align:center}
.modal-price-box .lbl{font-size:11px;color:var(--text-muted);text-transform:uppercase;margin-bottom:4px}
.modal-price-box .val{font-size:24px;font-weight:700}
.modal-price-box .val.green{color:var(--green)}
.modal-price-box .val.blue{color:var(--accent)}
.edge-breakdown{background:var(--bg);border-radius:10px;padding:16px}
.edge-row{display:flex;justify-content:space-between;padding:6px 0;border-bottom:1px solid var(--border);font-size:14px}
.edge-row:last-child{border:none}
.edge-row .el{color:var(--text-dim)}
.analysis-text{font-size:14px;line-height:1.7;color:var(--text-dim)}
.analysis-text p{margin-bottom:12px}
.analysis-text strong{color:var(--text)}
.modal-stats{display:grid;grid-template-columns:repeat(2,1fr);gap:12px}
.stat-box{background:var(--bg);border-radius:8px;padding:12px;font-size:13px}
.stat-box .sl{color:var(--text-muted);font-size:11px;text-transform:uppercase;margin-bottom:2px}
.modal-link{display:inline-flex;align-items:center;gap:6px;padding:10px 18px;background:var(--accent);color:#fff;border-radius:8px;font-weight:600;font-size:14px;margin-top:8px}
.modal-link:hover{opacity:.9;text-decoration:none}
.modal-ts{font-size:12px;color:var(--text-muted);margin-top:16px;text-align:right}

/* Visual bar for market vs model */
.compare-bar{height:32px;border-radius:8px;background:var(--bg);position:relative;margin:12px 0;overflow:hidden}
.compare-bar .market-line,.compare-bar .model-line{position:absolute;top:0;height:100%;width:3px;border-radius:2px}
.compare-bar .market-line{background:var(--red);z-index:2}
.compare-bar .model-line{background:var(--green);z-index:2}
.compare-bar .fill{position:absolute;top:0;left:0;height:100%;background:linear-gradient(90deg,var(--green-dim),transparent);border-radius:8px}
.compare-labels{display:flex;justify-content:space-between;font-size:11px;color:var(--text-muted)}

/* Tabs */
.tab-bar{display:flex;gap:0;padding:0 32px;border-bottom:1px solid var(--border);background:var(--bg)}
.tab-btn{padding:12px 24px;font-size:14px;font-weight:600;color:var(--text-dim);background:none;border:none;border-bottom:2px solid transparent;cursor:pointer;transition:all .2s}
.tab-btn:hover{color:var(--text)}
.tab-btn.active{color:var(--accent);border-bottom-color:var(--accent)}
.tab-content{display:none}
.tab-content.active{display:block}
.portfolio-summary-bar{display:inline-flex;align-items:center;gap:8px;padding:4px 12px;border-radius:8px;background:var(--card);border:1px solid var(--border);font-size:12px;font-weight:600;cursor:pointer}
.portfolio-summary-bar:hover{border-color:var(--accent)}

/* Mock Trade Button on cards */
.mock-trade-btn{padding:4px 10px;border-radius:6px;border:1px solid var(--border);background:var(--card);color:var(--text-dim);font-size:11px;cursor:pointer;transition:all .2s;white-space:nowrap}
.mock-trade-btn:hover{border-color:var(--accent);color:var(--accent);background:var(--card-hover)}

/* Trade Form Modal */
.trade-form-overlay{position:fixed;inset:0;background:rgba(0,0,0,.7);z-index:200;display:none;align-items:center;justify-content:center;padding:20px;backdrop-filter:blur(4px)}
.trade-form-overlay.open{display:flex}
.trade-form{background:var(--card);border:1px solid var(--border);border-radius:16px;max-width:480px;width:100%;padding:28px;position:relative}
.trade-form h3{font-size:18px;font-weight:700;margin-bottom:16px}
.trade-form label{display:block;font-size:12px;color:var(--text-dim);text-transform:uppercase;letter-spacing:.5px;margin-bottom:4px;margin-top:12px}
.trade-form input,.trade-form select,.trade-form textarea{width:100%;padding:10px 14px;border-radius:8px;border:1px solid var(--border);background:var(--bg);color:var(--text);font-size:14px;outline:none;font-family:inherit}
.trade-form input:focus,.trade-form select:focus,.trade-form textarea:focus{border-color:var(--accent)}
.trade-form textarea{resize:vertical;min-height:60px}
.trade-form-actions{display:flex;gap:10px;margin-top:20px}
.trade-form-actions button{flex:1;padding:10px;border-radius:8px;border:none;font-size:14px;font-weight:600;cursor:pointer}
.btn-confirm{background:var(--green);color:#000}
.btn-confirm:hover{opacity:.9}
.btn-cancel{background:var(--border);color:var(--text)}
.btn-cancel:hover{background:var(--card-hover)}

/* Portfolio Tab Styles */
.portfolio-dashboard{display:grid;grid-template-columns:repeat(auto-fit,minmax(160px,1fr));gap:14px;padding:24px 32px;border-bottom:1px solid var(--border)}
.portfolio-section{padding:24px 32px}
.portfolio-section h3{font-size:16px;font-weight:700;margin-bottom:16px;display:flex;align-items:center;gap:8px}
.portfolio-table{width:100%;border-collapse:collapse;font-size:13px}
.portfolio-table th{text-align:left;padding:10px 12px;border-bottom:1px solid var(--border);color:var(--text-dim);font-size:11px;text-transform:uppercase;letter-spacing:.5px;font-weight:600}
.portfolio-table td{padding:10px 12px;border-bottom:1px solid var(--border)}
.portfolio-table tr:hover{background:var(--card-hover)}
.close-pos-btn{padding:4px 10px;border-radius:6px;border:1px solid var(--red);background:transparent;color:var(--red);font-size:11px;cursor:pointer;font-weight:600}
.close-pos-btn:hover{background:var(--red-dim)}
.pnl-pos{color:var(--green)}
.pnl-neg{color:var(--red)}
.reasoning-toggle{color:var(--accent);cursor:pointer;font-size:11px}
.reasoning-expand{display:none;padding:8px 12px;background:var(--bg);border-radius:8px;margin-top:6px;font-size:12px;color:var(--text-dim);line-height:1.5}
.reasoning-expand.open{display:block}
.pnl-chart-container{padding:24px 32px}
.pnl-chart-container h3{font-size:16px;font-weight:700;margin-bottom:16px}
.pnl-chart-wrap{background:var(--card);border:1px solid var(--border);border-radius:12px;padding:20px;height:200px;position:relative}
.empty-state{text-align:center;padding:40px;color:var(--text-dim);font-size:14px}
.manual-trade-btn{padding:10px 20px;border-radius:8px;border:1px solid var(--accent);background:transparent;color:var(--accent);font-size:14px;font-weight:600;cursor:pointer;margin-left:auto}
.manual-trade-btn:hover{background:var(--accent);color:#fff}

/* Price Ticker */
.price-ticker{display:flex;gap:16px;padding:12px 32px;border-bottom:1px solid var(--border);background:#0d0e14;overflow-x:auto;flex-wrap:wrap}
.price-ticker .ticker-item{display:flex;align-items:center;gap:8px;font-size:13px;white-space:nowrap}
.price-ticker .ticker-asset{font-weight:600;color:var(--text)}
.price-ticker .ticker-price{color:var(--text-dim)}
.price-ticker .ticker-change{font-weight:600;font-size:12px}
.price-ticker .ticker-change.up{color:var(--green)}
.price-ticker .ticker-change.down{color:var(--red)}

/* Top 10 Section */
.top10-controls{padding:16px 32px;display:flex;gap:12px;align-items:center;border-bottom:1px solid var(--border)}
.btn-primary{padding:12px 24px;border-radius:10px;border:none;background:linear-gradient(135deg,var(--accent),#6366f1);color:#fff;font-size:14px;font-weight:700;cursor:pointer;transition:all .2s}
.btn-primary:hover{transform:translateY(-1px);box-shadow:0 4px 16px rgba(77,142,247,.3)}
.btn-secondary{padding:10px 18px;border-radius:8px;border:1px solid var(--border);background:var(--card);color:var(--text-dim);font-size:13px;cursor:pointer}
.btn-secondary:hover{border-color:var(--accent);color:var(--text)}
.btn-secondary.active{border-color:var(--accent);color:var(--accent)}

/* Ranked list for top 10 */
.ranked-list{padding:24px 32px;display:flex;flex-direction:column;gap:12px}
.ranked-item{display:flex;align-items:stretch;gap:16px;background:var(--card);border:1px solid var(--border);border-radius:14px;padding:20px;cursor:pointer;transition:all .2s;position:relative}
.ranked-item:hover{border-color:var(--accent);background:var(--card-hover);transform:translateY(-2px)}
.rank-badge{min-width:48px;display:flex;flex-direction:column;align-items:center;justify-content:center;font-size:24px;font-weight:800;color:var(--accent);border-right:1px solid var(--border);padding-right:16px}
.rank-badge.gold{color:#fbbf24}
.rank-badge.silver{color:#94a3b8}
.rank-badge.bronze{color:#cd7f32}
.ranked-body{flex:1;min-width:0}
.ranked-title{font-size:15px;font-weight:600;margin-bottom:8px;line-height:1.4}
.ranked-scores{display:flex;gap:12px;flex-wrap:wrap;margin-bottom:8px;font-size:12px}
.ranked-scores .score-pill{padding:3px 8px;border-radius:6px;background:var(--bg);color:var(--text-dim)}
.ranked-scores .score-pill strong{color:var(--text)}
.ranked-reasoning{font-size:13px;color:var(--text-dim);line-height:1.5}
.ranked-right{display:flex;flex-direction:column;align-items:flex-end;justify-content:center;min-width:100px;gap:4px}
.ranked-roi{font-size:22px;font-weight:700;color:var(--green)}
.ranked-action{font-size:12px;font-weight:600;padding:4px 10px;border-radius:6px}
.ranked-action.buy-yes{background:var(--green-dim);color:var(--green)}
.ranked-action.buy-no{background:#4d8ef722;color:var(--accent)}

/* Cross-market flag */
.cross-market-flag{font-size:11px;padding:3px 8px;border-radius:6px;background:#a855f722;color:var(--purple);font-weight:600}

/* Live price note */
.live-price-note{font-size:12px;color:var(--cyan);margin-top:4px;display:flex;align-items:center;gap:4px}

/* Scrollbar */
::-webkit-scrollbar{width:6px}
::-webkit-scrollbar-track{background:var(--bg)}
::-webkit-scrollbar-thumb{background:var(--border);border-radius:3px}

/* Donut */
.donut-wrap{display:flex;align-items:center;gap:16px}
.donut{width:80px;height:80px}

/* Loading */
.loading{text-align:center;padding:60px;color:var(--text-dim);font-size:16px}
.spinner{width:32px;height:32px;border:3px solid var(--border);border-top-color:var(--accent);border-radius:50%;animation:spin 1s linear infinite;margin:0 auto 16px}
@keyframes spin{to{transform:rotate(360deg)}}

/* Responsive */
@media(max-width:768px){
.header{padding:16px}
.dashboard{padding:16px;grid-template-columns:repeat(2,1fr)}
.controls{padding:12px 16px}
.grid{padding:16px;grid-template-columns:1fr}
.modal{padding:20px}
.modal-prices{grid-template-columns:1fr}
}
</style>
</head>
<body>

<div class="header">
<h1><span>üìä</span> Polymarket Scanner</h1>
<div class="header-meta">
<div class="portfolio-summary-bar" id="portfolioSummaryBar" onclick="switchTab('portfolio')" title="View portfolio">üìà Portfolio: $10,000 (+0.0%)</div>
<span id="autoTradingBadge" class="status-badge" style="background:var(--green-dim);color:var(--green);cursor:pointer;animation:pulse 2s infinite" onclick="switchTab('portfolio')">ü§ñ Auto | 0 pos | $0</span>
<span class="status-badge"><span class="live-dot"></span> Live Data</span>
<span id="lastUpdated">Loading...</span>
<button class="btn" onclick="fetchMarkets()" style="padding:6px 12px;font-size:12px;cursor:pointer" title="Refresh now">üîÑ Refresh</button>
</div>
</div>

<div class="tab-bar">
<button class="tab-btn active" data-tab="scanner" onclick="switchTab('scanner')">üîç Scanner</button>
<button class="tab-btn" data-tab="portfolio" onclick="switchTab('portfolio')">üìà Mock Portfolio</button>
</div>

<div class="tab-content active" id="tab-scanner">

<div class="price-ticker" id="priceTicker"></div>
<div class="dashboard" id="dashboard"></div>

<div class="controls">
<input type="text" class="search-box" id="searchBox" placeholder="Search markets...">
<select id="sortBy">
<option value="edge">Sort: Edge Size</option>
<option value="confidence">Sort: Confidence</option>
<option value="liquidity">Sort: Liquidity</option>
<option value="resolution">Sort: Time to Resolution</option>
<option value="volume">Sort: 24h Volume</option>
</select>
<div class="filter-group" id="catFilters"></div>
<select id="minConfidence">
<option value="all">All Confidence</option>
<option value="high">üü¢ High Only</option>
<option value="medium">üü° Medium+</option>
</select>
</div>

<div class="top10-controls" id="top10Controls">
<button class="btn-primary" id="btnTop10" onclick="showTop10()">üéØ Top 10 Opportunities</button>
<button class="btn-secondary active" id="btnAllMarkets" onclick="showAllMarkets()">üìã All Markets</button>
<span id="viewLabel" style="color:var(--text-dim);font-size:13px;margin-left:8px"></span>
</div>
<div class="ranked-list" id="top10List" style="display:none"></div>
<div class="grid" id="grid"><div class="loading"><div class="spinner"></div>Fetching markets from Polymarket...</div></div>

</div><!-- end tab-scanner -->

<div class="tab-content" id="tab-portfolio">
<div id="autoModeBar" style="padding:16px 32px;border-bottom:1px solid var(--border);display:flex;align-items:center;justify-content:space-between;flex-wrap:wrap;gap:12px"><div style="display:flex;align-items:center;gap:10px"><span style="font-size:20px">ü§ñ</span><span style="font-weight:700;font-size:16px">Autonomous Mode: <span style="color:var(--green)">ON</span></span><span style="font-size:12px;padding:3px 8px;border-radius:6px;background:var(--green-dim);color:var(--green)">Auto-trading every 60s</span></div><div style="display:flex;gap:16px;font-size:13px;color:var(--text-dim)"><span id="autoStats">Scanning...</span></div><div><button class="manual-trade-btn" onclick="openTradeForm()" style="font-size:12px;padding:6px 14px">‚úçÔ∏è Manual Override</button></div></div>
<div class="portfolio-dashboard" id="portfolioDashboard"></div>
<div class="pnl-chart-container">
<h3>üìä Portfolio Value Over Time</h3>
<div class="pnl-chart-wrap"><canvas id="pnlChart" style="width:100%;height:100%"></canvas></div>
</div>
<div class="portfolio-section">
<div style="display:flex;align-items:center;justify-content:space-between;margin-bottom:16px">
<h3 style="margin-bottom:0">üìÇ Open Positions</h3>
<button class="manual-trade-btn" onclick="openTradeForm()">+ New Trade</button>
</div>
<div id="openPositionsTable"></div>
</div>
<div class="portfolio-section">
<h3>üìú Closed Trades</h3>
<div id="closedTradesTable"></div>
</div>
<div class="portfolio-section">
<h3>üìã Trade Log</h3>
<div id="tradeLogSection"></div>
</div>
</div>

<div class="modal-overlay" id="modalOverlay">
<div class="modal" id="modal"></div>
</div>

<div class="trade-form-overlay" id="tradeFormOverlay">
<div class="trade-form" id="tradeForm"></div>
</div>

<script>
// ============================================
// POLYMARKET OPPORTUNITY SCANNER
// ============================================

const GAMMA_API = 'https://gamma-api.polymarket.com/markets';
const CORS_PROXY = 'https://corsproxy.io/?url=';
const CATEGORIES = {
  politics: { label: 'Politics', color: '#4d8ef7', class: 'tag-politics' },
  crypto: { label: 'Crypto', color: '#f59e0b', class: 'tag-crypto' },
  sports: { label: 'Sports', color: '#00d68f', class: 'tag-sports' },
  culture: { label: 'Culture', color: '#a855f7', class: 'tag-culture' },
  tech: { label: 'Tech', color: '#22d3ee', class: 'tag-tech' },
  economy: { label: 'Economy', color: '#eab308', class: 'tag-economy' },
  geopolitics: { label: 'Geopolitics', color: '#ff4d6a', class: 'tag-geopolitics' }
};

// Category detection from question text
function detectCategory(q, desc) {
  const t = (q + ' ' + (desc||'')).toLowerCase();
  if (/trump|biden|congress|senate|governor|election|shutdown|political|impeach|legislation|bill\b|democrat|republican|nominee|cabinet/.test(t)) return 'politics';
  if (/bitcoin|ethereum|btc|eth|crypto|solana|token|defi|nft|blockchain|binance/.test(t)) return 'crypto';
  if (/nba|nfl|mlb|soccer|football|basketball|superbowl|world cup|olympics|championship|mvp|game\s?\d/.test(t)) return 'sports';
  if (/oscar|grammy|movie|film|album|spotify|netflix|celebrity|taylor swift|kanye|elon/.test(t)) return 'culture';
  if (/ai\b|artificial intelligence|openai|google|apple|spacex|launch|robot|quantum|chip/.test(t)) return 'tech';
  if (/fed\b|interest rate|inflation|gdp|recession|unemployment|stock|s&p|dow|nasdaq|tariff|trade|cpi|fomc|treasury/.test(t)) return 'economy';
  if (/iran|ukraine|russia|china|war|strike|military|nato|sanctions|ceasefire|invasion/.test(t)) return 'geopolitics';
  return 'politics'; // default
}

// Extract event date from question text (returns Date or null)
function extractEventDate(question, endDate) {
  const q = question;
  const now = new Date();
  const currentYear = now.getFullYear();
  
  const MONTHS = {january:0,february:1,march:2,april:3,may:4,june:5,july:6,august:7,september:8,october:9,november:10,december:11,
    jan:0,feb:1,mar:2,apr:3,may:4,jun:5,jul:6,aug:7,sep:8,oct:9,nov:10,dec:11};
  
  function parseMonth(s) { return MONTHS[s.toLowerCase()]; }
  function makeDate(month, day, year) {
    const y = year || (endDate ? endDate.getFullYear() : currentYear);
    return new Date(y, month, day, 23, 59, 59);
  }

  // "on February 11, 2026" or "by February 14, 2026"
  let m1 = q.match(/(?:on|by|before)\s+(january|february|march|april|may|june|july|august|september|october|november|december|jan|feb|mar|apr|jun|jul|aug|sep|oct|nov|dec)\s+(\d{1,2})(?:st|nd|rd|th)?\s*,?\s*(\d{4})/i);
  if (m1) return makeDate(parseMonth(m1[1]), parseInt(m1[2]), parseInt(m1[3]));

  // "on February 11" (no year)
  let m2 = q.match(/(?:on|by|before)\s+(january|february|march|april|may|june|july|august|september|october|november|december|jan|feb|mar|apr|jun|jul|aug|sep|oct|nov|dec)\s+(\d{1,2})(?:st|nd|rd|th)?(?:\s|,|\?|!|\)|$)/i);
  if (m2) return makeDate(parseMonth(m2[1]), parseInt(m2[2]));

  // "February 9-15" or "February 9 - 15" (date range, use end)
  let m3 = q.match(/(january|february|march|april|may|june|july|august|september|october|november|december|jan|feb|mar|apr|jun|jul|aug|sep|oct|nov|dec)\s+(\d{1,2})\s*[-‚Äì]\s*(\d{1,2})(?:\s*,?\s*(\d{4}))?/i);
  if (m3) return makeDate(parseMonth(m3[1]), parseInt(m3[3]), m3[4] ? parseInt(m3[4]) : undefined);

  // "in February" or "in February 2026"
  let m4 = q.match(/in\s+(january|february|march|april|may|june|july|august|september|october|november|december|jan|feb|mar|apr|jun|jul|aug|sep|oct|nov|dec)(?:\s+(\d{4}))?/i);
  if (m4) {
    const mo = parseMonth(m4[1]);
    const yr = m4[2] ? parseInt(m4[2]) : (endDate ? endDate.getFullYear() : currentYear);
    // End of month
    return new Date(yr, mo + 1, 0, 23, 59, 59);
  }

  // "on Saturday" / "on Friday" etc ‚Äî resolve using endDate as hint
  const DAYS = {sunday:0,monday:1,tuesday:2,wednesday:3,thursday:4,friday:5,saturday:6};
  let m5 = q.match(/(?:on|by|this)\s+(sunday|monday|tuesday|wednesday|thursday|friday|saturday)/i);
  if (m5 && endDate) {
    const targetDay = DAYS[m5[1].toLowerCase()];
    // Find the closest matching day on or before endDate
    const d = new Date(endDate);
    while (d.getDay() !== targetDay && d > new Date(now.getTime() - 14*86400000)) {
      d.setDate(d.getDate() - 1);
    }
    if (d.getDay() === targetDay) return new Date(d.getFullYear(), d.getMonth(), d.getDate(), 23, 59, 59);
  }

  // "after the March 2026 meeting" (FOMC)
  let m6 = q.match(/(?:after|following)\s+(?:the\s+)?(january|february|march|april|may|june|july|august|september|october|november|december|jan|feb|mar|apr|jun|jul|aug|sep|oct|nov|dec)(?:\s+(\d{4}))?\s+(?:FOMC\s+)?meeting/i);
  if (m6) {
    // Use endDate as proxy for FOMC meeting date
    if (endDate) return endDate;
  }

  return null;
}

// Analyze a market and generate model estimate + thesis
function analyzeMarket(m) {
  const q = m.question;
  let price;
  try { price = parseFloat(JSON.parse(m.outcomePrices)[0]); } catch(e) { price = 0.5; }
  const cat = detectCategory(q, m.description);
  const dateStr = m.endDate || m.endDateIso || null;
  const endDate = dateStr ? new Date(dateStr) : new Date(Date.now() + 30*86400000);
  const now = new Date();
  
  // Extract event date from question and use earlier of (event date, endDate)
  const eventDate = extractEventDate(q, endDate);
  const effectiveDate = eventDate && eventDate < endDate ? eventDate : endDate;
  const eventWindowPassed = eventDate && eventDate < now;
  
  const daysLeft = isNaN(effectiveDate.getTime()) ? 30 : Math.max(0, Math.ceil((effectiveDate - now) / 86400000));
  const vol24h = m.volume24hr || 0;
  const totalVol = m.volumeNum || 0;
  const liq = m.liquidityNum || 0;
  const spread = m.spread || 0;

  // Analyze news sentiment if available
  const newsSignals = m.news ? analyzeNewsSentiment(m.news, q, daysLeft) : null;

  // Model estimate based on heuristics
  let modelEstimate, confidence, reasoning;

  // If event window has passed, override analysis
  if (eventWindowPassed) {
    if (price > 0.8) {
      modelEstimate = Math.max(price, price + (1 - price) * 0.1);
      confidence = 'medium';
      reasoning = `<p><strong>‚è∞ Event date has passed.</strong> The specific date in the question (${eventDate.toLocaleDateString()}) is already past. The high price of ${(price*100).toFixed(1)}¬¢ indicates the event likely occurred. The market should resolve YES soon.</p>
      <p><strong>Our view:</strong> Agree with market direction. No reason to bet against a likely resolved outcome.</p>`;
    } else if (price < 0.2) {
      modelEstimate = Math.min(price, price * 0.9);
      confidence = 'medium';
      reasoning = `<p><strong>‚è∞ Event date has passed.</strong> The specific date in the question (${eventDate.toLocaleDateString()}) is already past. The low price of ${(price*100).toFixed(1)}¬¢ indicates the event likely did NOT occur. The market should resolve NO soon.</p>
      <p><strong>Our view:</strong> Agree with market direction. No reason to bet against a likely resolved outcome.</p>`;
    } else {
      modelEstimate = price;
      confidence = 'low';
      reasoning = `<p><strong>‚è∞ Event date has passed.</strong> The specific date in the question (${eventDate.toLocaleDateString()}) is already past, but the price is mid-range at ${(price*100).toFixed(1)}¬¢ ‚Äî the outcome is unclear. Proceed with caution.</p>`;
    }
  } else {
    const groupContext = {
      groupItemTitle: m.groupItemTitle || null,
      groupItemThreshold: m.groupItemThreshold || null,
      negRiskMarketID: m.negRiskMarketID || null
    };
    const analysis = generateAnalysis(q, m.description, price, cat, daysLeft, vol24h, liq, m, newsSignals, groupContext);
    modelEstimate = analysis.estimate;
    confidence = analysis.confidence;
    reasoning = analysis.reasoning;
    if (eventDate && daysLeft <= 1 && daysLeft >= 0) {
      reasoning = `<p><strong>‚è∞ Event date is today/tomorrow</strong> (${eventDate.toLocaleDateString()}). Resolution imminent.</p>` + reasoning;
    }
  }

  const edge = Math.abs(modelEstimate - price);
  const direction = modelEstimate > price ? 'BUY YES' : 'BUY NO';
  const entryPrice = direction === 'BUY YES' ? price : (1 - price);
  const returnPct = entryPrice > 0 ? (edge / entryPrice) : 0; // ROI: edge relative to what you pay
  
  // Liquidity score 1-3
  let liqScore = 1;
  if (liq > 500000) liqScore = 3;
  else if (liq > 50000) liqScore = 2;

  // Deep analysis for high-ROI opportunities (>50%)
  let deepAnalysis = null;
  if (returnPct > 0.5) {
    deepAnalysis = generateDeepAnalysis(q, m.description, price, modelEstimate, edge, returnPct, direction, confidence, cat, daysLeft, vol24h, liq, m);
  }

  return {
    id: m.id,
    question: q,
    slug: m.slug,
    description: m.description,
    category: cat,
    marketPrice: price,
    modelEstimate,
    edge,
    returnPct,
    entryPrice,
    direction,
    confidence,
    liqScore,
    liquidity: liq,
    volume24h: vol24h,
    totalVolume: totalVol,
    spread,
    daysLeft,
    endDate: isNaN(endDate.getTime()) ? 'Unknown' : endDate.toISOString(),
    eventDate: eventDate ? eventDate.toISOString() : null,
    effectiveDate: effectiveDate.toISOString(),
    eventWindowPassed: !!eventWindowPassed,
    reasoning,
    image: m.image,
    bestBid: m.bestBid,
    bestAsk: m.bestAsk,
    oneDayChange: m.oneDayPriceChange,
    oneWeekChange: m.oneWeekPriceChange,
    news: m.news || null,
    newsSignals,
    deepAnalysis
  };
}

function analyzeNewsSentiment(newsItems, question, daysLeft) {
  const BULLISH_WORDS = /\b(passes|passed|approved|confirms|confirmed|wins|won|signs|signed|agrees|agreed|closes|closed|rises|rising|surges|soars|rallies|record high|breakthrough|deal|success)\b/i;
  const BEARISH_WORDS = /\b(fails|failed|rejected|rejects|unlikely|delays|delayed|blocks|blocked|falls|falling|drops|crashes|collapses|stalls|opposes|vetoes|denied|loses|lost)\b/i;
  const NEUTRAL_WORDS = /\b(expected|likely|predicted|forecast|may|could|might|considers|considering|discusses|plans|proposes)\b/i;

  const now = new Date();
  const signals = newsItems.map(item => {
    const text = (item.title + ' ' + (item.description || '')).toLowerCase();
    let sentiment = 0; // -1 to 1
    let label = 'neutral';

    const bullishMatches = text.match(BULLISH_WORDS);
    const bearishMatches = text.match(BEARISH_WORDS);

    if (bullishMatches && !bearishMatches) { sentiment = 0.6; label = 'bullish'; }
    else if (bearishMatches && !bullishMatches) { sentiment = -0.6; label = 'bearish'; }
    else if (bullishMatches && bearishMatches) { sentiment = 0; label = 'mixed'; }
    else if (NEUTRAL_WORDS.test(text)) { sentiment = 0.15; label = 'lean-yes'; }

    // Recency weight
    const pubDate = item.publishedAt ? new Date(item.publishedAt) : null;
    const hoursAgo = pubDate ? (now - pubDate) / 3600000 : 48;
    const recencyWeight = hoursAgo < 6 ? 1.0 : hoursAgo < 24 ? 0.7 : hoursAgo < 48 ? 0.4 : 0.2;

    // Time-to-resolution weight: news matters more when close to resolution
    const timeWeight = daysLeft <= 1 ? 1.0 : daysLeft <= 3 ? 0.7 : daysLeft <= 7 ? 0.5 : 0.3;

    const weight = recencyWeight * timeWeight;

    return {
      title: item.title,
      source: item.source,
      url: item.url,
      publishedAt: item.publishedAt,
      hoursAgo: Math.round(hoursAgo),
      sentiment,
      label,
      weight
    };
  });

  // Aggregate
  let totalWeight = 0, weightedSentiment = 0;
  for (const s of signals) {
    if (s.sentiment !== 0) {
      weightedSentiment += s.sentiment * s.weight;
      totalWeight += s.weight;
    }
  }
  const avgSentiment = totalWeight > 0 ? weightedSentiment / totalWeight : 0;

  // Agreement factor: if multiple headlines agree, boost confidence
  const agreeing = signals.filter(s => Math.sign(s.sentiment) === Math.sign(avgSentiment) && s.sentiment !== 0).length;
  const agreementBoost = agreeing >= 3 ? 1.5 : agreeing >= 2 ? 1.2 : 1.0;

  // Final adjustment to model estimate (capped)
  const rawAdjustment = avgSentiment * 0.08 * agreementBoost;
  const adjustment = Math.max(-0.12, Math.min(0.12, rawAdjustment));

  return {
    signals,
    avgSentiment,
    adjustment,
    agreementLevel: agreeing,
    hasNews: signals.length > 0
  };
}

function generateDeepAnalysis(q, desc, price, modelEstimate, edge, returnPct, direction, confidence, cat, daysLeft, vol24h, liq, raw) {
  const ql = q.toLowerCase();
  
  // Determine confidence level for sizing
  let confLevel = 'low';
  if (confidence === 'high' && liq > 200000) confLevel = 'high';
  else if (confidence === 'medium' || liq > 100000) confLevel = 'medium';
  
  // Why the model sees edge
  let whyEdge = '';
  if (price < 0.1) {
    whyEdge = `The market prices this at just ${(price*100).toFixed(1)}¬¢, implying near-impossibility. Our model sees ${(modelEstimate*100).toFixed(1)}% fair value ‚Äî still unlikely, but the market may be too dismissive. Lottery-ticket bias works both ways: sometimes cheap things are cheap for a reason, but structural underpricing of tail risks does occur.`;
  } else if (price > 0.9) {
    whyEdge = `At ${(price*100).toFixed(1)}¬¢, the market is highly confident. Our model agrees with the direction but sees it as slightly underpriced at ${(modelEstimate*100).toFixed(1)}¬¢. The edge comes from favorite-longshot bias ‚Äî bettors systematically underprice near-certainties.`;
  } else if (Math.abs(raw.oneDayPriceChange || 0) > 0.1) {
    whyEdge = `A sharp ${((raw.oneDayPriceChange||0)*100).toFixed(1)}¬¢ move in 24h suggests overreaction. Markets with ${daysLeft}+ days to resolution tend to mean-revert after sudden moves. The edge is a partial fade of this momentum.`;
  } else {
    whyEdge = `The model identifies a ${(edge*100).toFixed(1)}pp gap between market price (${(price*100).toFixed(1)}¬¢) and estimated fair value (${(modelEstimate*100).toFixed(1)}¬¢). At ${(returnPct*100).toFixed(0)}% ROI, this represents a significant risk/reward opportunity if the thesis is correct.`;
  }
  
  // Risk factors
  let risks = [];
  if (liq < 50000) risks.push('‚ö†Ô∏è Low liquidity ($' + formatNum(liq) + ') ‚Äî slippage risk on entry/exit');
  if (daysLeft > 30) risks.push('‚è≥ Long time horizon (' + daysLeft + ' days) ‚Äî many things can change');
  if (daysLeft <= 1) risks.push('‚è∞ Resolves very soon ‚Äî limited time to react if wrong');
  if (price < 0.05) risks.push('üé∞ Extreme longshot ‚Äî most of these resolve to NO');
  if (price > 0.95) risks.push('üìå Near-certain market ‚Äî edge is real but tiny in absolute terms');
  if ((raw.oneDayPriceChange || 0) < -0.1) risks.push('üìâ Sharply declining ‚Äî momentum could continue');
  if ((raw.oneDayPriceChange || 0) > 0.1) risks.push('üìà Sharply rising ‚Äî may already be priced in');
  if (vol24h < 10000) risks.push('üîá Low volume ‚Äî market may be stale/inefficient OR abandoned');
  if (risks.length === 0) risks.push('Standard prediction market risks apply ‚Äî model could be miscalibrated');
  
  // Key question
  let keyQuestion = '';
  if (/shutdown/.test(ql)) keyQuestion = 'Is this a "new" shutdown or continuation of the existing one? The resolution criteria matter enormously here.';
  else if (/fed|fomc|interest rate/.test(ql)) keyQuestion = 'Has there been any shift in Fed communication or economic data that the market hasn\'t fully absorbed?';
  else if (/bitcoin|ethereum|btc|eth|crypto/.test(ql)) keyQuestion = 'Is there a catalyst (ETF flows, regulatory news, macro shift) that could move the price to this level in the timeframe?';
  else if (/trump|biden|elect/.test(ql)) keyQuestion = 'Is there insider/institutional information the market is pricing that you don\'t have?';
  else if (/war|strike|military/.test(ql)) keyQuestion = 'Geopolitical events are fat-tailed ‚Äî is the current price reflecting the true tail risk, or is it noise?';
  else keyQuestion = 'What does the smart money know? Check if large recent trades have moved the price ‚Äî that\'s where the real signal is.';
  
  return {
    whyEdge,
    risks,
    sizingHint: `High edge (${(returnPct*100).toFixed(0)}% ROI) but ${confLevel} confidence ‚Äî size accordingly.${confLevel === 'low' ? ' Consider this a small speculative position at most.' : confLevel === 'medium' ? ' Moderate position if thesis holds up to scrutiny.' : ' Reasonable to take a meaningful position.'}`,
    keyQuestion,
    confLevel
  };
}

function generateAnalysis(q, desc, price, cat, daysLeft, vol24h, liq, raw, newsSignals, groupContext) {
  const ql = q.toLowerCase();
  let estimate, confidence, reasoning;

  // === GROUP-AWARE ANALYSIS for related/bracket markets ===
  if (groupContext && groupContext.groupItemTitle) {
    const threshold = groupContext.groupItemThreshold;
    const title = groupContext.groupItemTitle;
    
    // Parse numeric threshold from title or threshold field
    let thresholdNum = null;
    if (threshold != null && !isNaN(parseFloat(threshold))) {
      thresholdNum = parseFloat(threshold);
    } else {
      const numMatch = title.match(/([\d.]+)\+?/);
      if (numMatch) thresholdNum = parseFloat(numMatch[1]);
    }
    
    // Detect bracket/duration patterns
    const isDuration = /last|day|hour|week|month/i.test(ql + ' ' + title);
    const isPriceTarget = /reach|\$|price|above|below/i.test(ql + ' ' + title);
    const isBpsTarget = /bps|basis point|bp\b/i.test(ql + ' ' + title);
    
    if (thresholdNum !== null && (isDuration || isPriceTarget || isBpsTarget)) {
      let groupNote = '';
      
      // If price is very low (<10¬¢) and this is a bracket market, it's likely already exceeded or impossible
      if (price < 0.10 && isDuration && daysLeft === 0) {
        groupNote = `<p><strong>üîó Group context:</strong> This is a bracket market (threshold: ${title}). The very low price of ${(price*100).toFixed(1)}¬¢ near resolution suggests this threshold has likely already been passed or is no longer achievable. <strong>No actionable edge</strong> ‚Äî the market is correctly pricing a near-impossible outcome.</p>`;
        // Override: agree with market, no edge
        estimate = Math.min(price, price * 0.9);
        confidence = 'low';
        reasoning = groupNote + `<p><strong>Our view:</strong> This bracket is effectively dead. The market price reflects that this specific threshold is no longer in play. Look at adjacent brackets in the same group for live opportunities.</p>`;
        return { estimate, confidence, reasoning };
      }
      
      if (price > 0.90 && isDuration && daysLeft === 0) {
        groupNote = `<p><strong>üîó Group context:</strong> This is a bracket market (threshold: ${title}). The high price of ${(price*100).toFixed(1)}¬¢ near resolution suggests this is the winning bracket. The market is converging on this outcome.</p>`;
        estimate = Math.max(price, price + (1 - price) * 0.05);
        confidence = 'low';
        reasoning = groupNote + `<p><strong>Our view:</strong> This appears to be the resolving bracket. Minimal edge remains ‚Äî the market has largely priced in the outcome.</p>`;
        return { estimate, confidence, reasoning };
      }
      
      // For active bracket markets with time remaining
      if (daysLeft > 0) {
        groupNote = `<p><strong>üîó Bracket market:</strong> "${title}" ‚Äî this is one of several mutually exclusive outcomes in the same event group. `;
        if (isDuration) {
          groupNote += `The threshold is ${thresholdNum} ${/day/i.test(title) ? 'days' : /hour/i.test(title) ? 'hours' : 'units'}. Consider how the current situation tracks against ALL brackets, not just this one.</p>`;
        } else if (isPriceTarget) {
          groupNote += `The price target is $${thresholdNum}. Consider current price trajectory and volatility against ALL brackets.</p>`;
        } else {
          groupNote += `The threshold is ${thresholdNum}. Consider the current value relative to ALL brackets.</p>`;
        }
      }
      
      // If we have a group note but didn't early-return, prepend it to normal analysis
      if (groupNote) {
        // Fall through to normal analysis but prepend group context
        const base = _generateBaseAnalysis(q, desc, price, cat, daysLeft, vol24h, liq, raw, newsSignals);
        return { estimate: base.estimate, confidence: base.confidence, reasoning: groupNote + base.reasoning };
      }
    }
  }

  return _generateBaseAnalysis(q, desc, price, cat, daysLeft, vol24h, liq, raw, newsSignals);
}

function _generateBaseAnalysis(q, desc, price, cat, daysLeft, vol24h, liq, raw, newsSignals) {
  const ql = q.toLowerCase();
  let estimate, confidence, reasoning;

  // Government shutdown
  if (/shutdown/.test(ql) && /saturday|february 14/.test(ql)) {
    estimate = 0.08;
    confidence = 'high';
    reasoning = `<p><strong>What the market is pricing:</strong> At ${(price*100).toFixed(1)}¬¢, the market implies a ~${(price*100).toFixed(0)}% chance of a new government shutdown by tomorrow. This follows the partial shutdown that began January 31.</p>
    <p><strong>Our view:</strong> The key distinction here is "new" shutdown ‚Äî the existing partial shutdown doesn't qualify. Congressional leadership has signaled a continuing resolution is being negotiated, and with both parties motivated to avoid blame heading into a long weekend, the probability of an entirely new shutdown event is lower than the market suggests. We estimate ~8% fair value.</p>
    <p><strong>Key risks:</strong> Political brinkmanship could escalate unexpectedly. The narrow timeframe (tomorrow) means this is essentially a binary bet on whether negotiations collapse in the next 24 hours. The 83¬¢ one-day price drop suggests the market is rapidly repricing downward ‚Äî momentum favors NO.</p>`;
  }
  // Fed Chair nomination
  else if (/judy shelton/.test(ql) && /fed chair/.test(ql)) {
    estimate = 0.04;
    confidence = 'medium';
    reasoning = `<p><strong>What the market is pricing:</strong> Judy Shelton at 2.65¬¢ reflects her as a long-shot candidate for Fed Chair nomination. The broader "Who will Trump nominate" event has $473M in volume ‚Äî this is one of Polymarket's most liquid markets.</p>
    <p><strong>Our view:</strong> Shelton's previous Fed Board nomination failed in the Senate (50-47 against) in 2020, which should reduce her odds. However, Trump has a pattern of revisiting rejected nominees when he has more political leverage. With Kevin Hassett and Kevin Warsh as frontrunners, Shelton at 2.65¬¢ may be slightly underpriced given Trump's unpredictability. We estimate ~4% fair value.</p>
    <p><strong>Key risks:</strong> This is a long-dated market (Dec 2026) with high uncertainty. The Senate confirmation math has changed, and Trump's second-term approach to nominations has been more aggressive. Dark horse risk is real here.</p>`;
  }
  // ETH price targets
  else if (/ethereum.*4.?400/.test(ql)) {
    estimate = 0.003;
    confidence = 'medium';
    reasoning = `<p><strong>What the market is pricing:</strong> ETH reaching $4,400 in February at 0.25¬¢ implies near-impossibility. ETH is currently trading around $2,700-2,800, meaning this requires a ~60% rally in under two weeks.</p>
    <p><strong>Our view:</strong> This is fairly priced. While crypto can see violent moves, a 60% ETH rally in 15 days has essentially no historical precedent outside of the 2017 ICO mania. The market isn't mispriced here ‚Äî it's correctly reflecting near-zero probability. Slight edge exists on the NO side at 99.75¬¢ for those wanting very safe yield.</p>
    <p><strong>Key risks:</strong> Black swan crypto events (unexpected ETF flows, regulatory surprise) could theoretically drive a moonshot, but the risk/reward doesn't justify a YES position.</p>`;
  }
  // US strikes Iran
  else if (/us strikes iran/.test(ql)) {
    estimate = 0.008;
    confidence = 'low';
    reasoning = `<p><strong>What the market is pricing:</strong> At 0.55¬¢, the market sees virtually no chance of US strikes on Iran by February 13. The one-week price drop of 10.95¬¢ suggests this was recently much more actively traded, likely around a geopolitical flashpoint.</p>
    <p><strong>Our view:</strong> The sharp decline suggests whatever catalyst drove prices up has dissipated. With the date being today/tomorrow, and no current intelligence suggesting imminent military action, the NO side looks correct but slightly overpriced. We see ~0.8% fair value ‚Äî the tiny premium reflects residual geopolitical tail risk.</p>
    <p><strong>Key risks:</strong> Geopolitical events are inherently unpredictable. A provocation or intelligence failure could rapidly change the calculus. However, the extremely short timeframe limits exposure.</p>`;
  }
  // Fed rate decision - 50bps decrease
  else if (/fed.*decrease.*50/.test(ql) && /march/.test(ql)) {
    estimate = 0.005;
    confidence = 'high';
    reasoning = `<p><strong>What the market is pricing:</strong> A 50+ bps rate cut at the March FOMC meeting is priced at 0.65¬¢. The CME FedWatch tool and bond markets strongly agree ‚Äî an aggressive cut is extremely unlikely given current conditions.</p>
    <p><strong>Our view:</strong> With inflation still above target and the labor market resilient, the Fed has no reason to cut aggressively. Powell's recent communications have emphasized patience. The 92.5¬¢ "no change" market for the same meeting confirms the consensus. Fair value is ~0.5¬¢ ‚Äî the market is slightly generous to YES buyers.</p>
    <p><strong>Key risks:</strong> Only a severe financial crisis or deflationary shock before March 18 would warrant an emergency cut of this magnitude. The spread between market (0.65¬¢) and our estimate (0.5¬¢) is thin but real.</p>`;
  }
  // Fed no change
  else if (/no change.*fed.*march/.test(ql)) {
    estimate = 0.935;
    confidence = 'high';
    reasoning = `<p><strong>What the market is pricing:</strong> No change in Fed rates after March at 92.5¬¢ implies a 92.5% probability of rates staying put. This aligns closely with CME FedWatch probabilities and market consensus.</p>
    <p><strong>Our view:</strong> We see this as slightly underpriced at 93.5%. The Fed has been extremely clear about holding steady, and February CPI/employment data would need to be dramatically different from expectations to shift the calculus in just one meeting. The "25 bps cut" outcome gets the remaining probability.</p>
    <p><strong>Key risks:</strong> A tariff-induced economic shock or banking stress event could force the Fed's hand, but the bar is very high for March action. This is a high-confidence, low-edge opportunity ‚Äî good for capital preservation strategies.</p>`;
  }
  // Generic analysis engine
  else {
    // Heuristic model: adjust price based on common biases
    const bias = analyzeBias(price, daysLeft, vol24h, liq, raw);
    let totalAdj = bias.adjustment;
    let newsNote = '';
    if (newsSignals && newsSignals.hasNews && newsSignals.adjustment !== 0) {
      totalAdj += newsSignals.adjustment;
      const dir = newsSignals.adjustment > 0 ? 'bullish (YES)' : 'bearish (NO)';
      newsNote = `<p><strong>üì∞ News signal:</strong> Recent headlines lean ${dir}, adjusting our estimate by ${(newsSignals.adjustment*100).toFixed(1)}pp. ${newsSignals.agreementLevel >= 3 ? 'Multiple sources agree, increasing conviction.' : ''}</p>`;
    }
    estimate = Math.max(0.001, Math.min(0.999, price + totalAdj));
    confidence = bias.confidence;
    if (newsSignals && newsSignals.hasNews && Math.abs(newsSignals.adjustment) > 0.03 && confidence === 'low') confidence = 'medium';
    reasoning = `<p><strong>What the market is pricing:</strong> "${q}" is trading at ${(price*100).toFixed(1)}¬¢ YES / ${((1-price)*100).toFixed(1)}¬¢ NO${daysLeft > 0 ? `, with ${daysLeft} days until resolution` : ''}. 24-hour volume is $${formatNum(vol24h)}.</p>
    <p><strong>Our view:</strong> ${bias.thesis}</p>
    ${newsNote}
    <p><strong>Key factors:</strong> ${bias.factors}</p>`;
  }

  return { estimate, confidence, reasoning };
}

function analyzeBias(price, daysLeft, vol24h, liq, raw) {
  let adjustment = 0;
  let thesis = '';
  let factors = '';
  let confidence = 'medium';

  const dayChange = raw.oneDayPriceChange || 0;
  const weekChange = raw.oneWeekPriceChange || 0;

  // === RESOLVED / RESOLVING MARKETS (daysLeft === 0) ===
  // When a market is at its resolution date, price moves reflect the ACTUAL OUTCOME,
  // not tradeable overreactions. Never fade a resolved market.
  if (daysLeft === 0) {
    if (price > 0.8) {
      // YES outcome likely happened ‚Äî agree with market or nudge higher
      adjustment = Math.max(0, (1 - price) * 0.1); // Tiny nudge toward 100%, never below market
      thesis = `This market is at its resolution date. The price at ${(price*100).toFixed(0)}¬¢ YES indicates the outcome has likely occurred or is being confirmed. The sharp price movement reflects the actual outcome being priced in, not a tradeable overreaction.`;
      factors = `Market is resolved or resolving. Price reflects the actual outcome. No edge exists against the direction of resolution.`;
    } else if (price < 0.2) {
      // NO outcome likely happened ‚Äî agree with market or nudge lower
      adjustment = Math.min(0, -(price) * 0.1); // Tiny nudge toward 0%, never above market
      thesis = `This market is at its resolution date. The price at ${(price*100).toFixed(0)}¬¢ YES indicates the YES outcome has likely NOT occurred. The price movement reflects the actual outcome being priced in, not a tradeable overreaction.`;
      factors = `Market is resolved or resolving. Price reflects the actual outcome. No edge exists against the direction of resolution.`;
    } else {
      // Resolution day but price is mid-range ‚Äî genuinely uncertain
      adjustment = 0;
      thesis = `This market is at its resolution date but the price remains mid-range at ${(price*100).toFixed(0)}¬¢, suggesting the outcome is still genuinely uncertain. The result should be known very soon.`;
      factors = `Resolution imminent. Outcome not yet determined. High uncertainty remains.`;
    }
    confidence = 'low';
    return { adjustment, thesis, factors, confidence };
  }

  // === NEAR-RESOLUTION MARKETS (daysLeft <= 1) ===
  // Large moves close to resolution are resolution SIGNALS, not overreactions.
  if (daysLeft <= 1 && Math.abs(dayChange) > 0.2) {
    // Big move near resolution = the answer is being priced in
    // AGREE with the move direction, don't fade it
    if (dayChange > 0) {
      adjustment = Math.max(0, dayChange * 0.05); // Small nudge WITH the move
    } else {
      adjustment = Math.min(0, dayChange * 0.05); // Small nudge WITH the move
    }
    thesis = `This market resolves in ${daysLeft} day(s) and has moved ${(dayChange*100).toFixed(1)}¬¢ in the last 24 hours. Near resolution, large moves typically reflect emerging information about the actual outcome ‚Äî this is a resolution signal, not an overreaction to fade.`;
    factors = `Near-resolution large move interpreted as outcome signal. The market is converging on the answer. Limited edge available.`;
    confidence = 'low';
    return { adjustment, thesis, factors, confidence };
  }

  // === ESSENTIALLY DECIDED MARKETS (>95% or <5%) ===
  // Regardless of time remaining, these are near-certain. Track the market closely.
  if (price > 0.95) {
    adjustment = Math.min(0.005, (1 - price) * 0.15); // Tiny nudge toward 100%, never away
    thesis = `This market is pricing at ${(price*100).toFixed(1)}% ‚Äî near certainty. The consensus is overwhelming and likely correct. Only micro-edges from structural biases (capital opportunity cost on locked-up funds).`;
    factors = `Near-certain market. Only structural micro-edges exist.`;
    confidence = 'low';
    return { adjustment, thesis, factors, confidence };
  }
  if (price < 0.05) {
    adjustment = Math.max(-0.005, -(price) * 0.15); // Tiny nudge toward 0%, never away
    thesis = `This market is pricing at ${(price*100).toFixed(1)}% ‚Äî near zero probability. Extreme longshots tend to be slightly overpriced due to lottery-ticket bias. Minimal edge on NO.`;
    factors = `Near-certain market. Only structural micro-edges exist.`;
    confidence = 'low';
    return { adjustment, thesis, factors, confidence };
  }

  // === ACTIVE MARKETS WITH REAL UNCERTAINTY ===

  // Recency bias: sharp recent moves often overshoot ‚Äî BUT ONLY for markets with time left
  if (Math.abs(dayChange) > 0.1 && daysLeft > 3) {
    adjustment = -dayChange * 0.15;
    thesis = `The market moved ${(dayChange*100).toFixed(1)}¬¢ in the last 24 hours, which suggests potential overreaction. Large single-day moves in prediction markets tend to overshoot by 10-20% before mean-reverting. We're fading a portion of this move.`;
    factors = `Momentum and mean-reversion dynamics. High 24h volume ($${formatNum(vol24h)}) confirms active repricing, but late movers often push prices past fair value.`;
    confidence = 'medium';
  } else if (Math.abs(dayChange) > 0.1 && daysLeft <= 3) {
    // Near resolution with big move but not huge (0.1-0.2 range) ‚Äî lean with the move
    if (dayChange > 0) {
      adjustment = Math.max(0, dayChange * 0.05);
    } else {
      adjustment = Math.min(0, dayChange * 0.05);
    }
    thesis = `The market moved ${(dayChange*100).toFixed(1)}¬¢ in the last 24 hours with only ${daysLeft} day(s) to resolution. Near-expiry moves are more likely to reflect real information than overreaction. We lean with the move direction.`;
    factors = `Near-resolution momentum. Information-driven repricing is more likely than noise this close to the outcome.`;
    confidence = 'low';
  } else if (price > 0.85 || price < 0.15) {
    // Moderate extreme prices: favorite-longshot bias
    if (price > 0.85) {
      adjustment = 0.02;
      thesis = `High-probability events (>${(price*100).toFixed(0)}%) are historically slightly underpriced in prediction markets due to the favorite-longshot bias. Bettors over-allocate to longshots, leaving value on heavy favorites.`;
    } else {
      adjustment = -0.005;
      thesis = `Low-probability events (<${(price*100).toFixed(0)}%) are historically overpriced in prediction markets. Bettors are drawn to cheap lottery-ticket odds, inflating prices above true probability. We see slight value on NO.`;
    }
    factors = `Favorite-longshot bias is well-documented in both prediction markets and sports betting. Liquidity at $${formatNum(liq)} is ${liq > 100000 ? 'sufficient for meaningful positions' : 'thin ‚Äî position size accordingly'}.`;
    confidence = liq > 200000 ? 'medium' : 'low';
  } else if (daysLeft < 3 && daysLeft > 0) {
    // Near resolution: time decay
    if (price > 0.4 && price < 0.6) {
      adjustment = 0;
      thesis = `With ${daysLeft} day(s) to resolution and the price near 50/50, this is essentially a coin flip. No clear edge ‚Äî the market is efficiently pricing uncertainty.`;
      confidence = 'low';
    } else {
      adjustment = price > 0.5 ? 0.03 : -0.03;
      thesis = `Near-resolution markets tend to accelerate toward their final outcome. With ${daysLeft} day(s) left and the price at ${(price*100).toFixed(0)}¬¢, momentum suggests the current direction will hold.`;
      confidence = 'medium';
    }
    factors = `Time decay and information asymmetry. Traders with superior information tend to move prices early, and late pricing tends to be correct.`;
  } else {
    // Default: slight mean reversion
    adjustment = (0.5 - price) * 0.03;
    thesis = `The market appears reasonably efficient at current levels. Our model sees a minor adjustment based on mean-reversion tendencies and volume-weighted momentum analysis.`;
    factors = `Market efficiency, volume patterns, and historical base rates for similar event types. ${daysLeft > 30 ? 'The long time horizon introduces significant uncertainty.' : 'The medium-term horizon allows for meaningful position building.'}`;
    confidence = 'low';
  }

  return { adjustment, thesis, factors, confidence };
}

function formatNum(n) {
  if (n >= 1e6) return (n/1e6).toFixed(1) + 'M';
  if (n >= 1e3) return (n/1e3).toFixed(0) + 'K';
  return n.toFixed(0);
}

function formatMoney(n) {
  return '$' + formatNum(n);
}

// ============================================
// DATA FETCHING
// ============================================

let allOpportunities = [];
let activeCategory = 'all';
let totalScanned = 0;
let livePrices = {};
let crossMarketGroups = {};
let currentView = 'all'; // 'top10' or 'all'

async function fetchMarkets() {
  try {
    let markets = [];
    
    let apiLivePrices = {};
    
    // Use our own Vercel serverless proxy to avoid CORS
    try {
      const res = await fetch('/api/markets');
      if (res.ok) {
        const data = await res.json();
        markets = data.markets || [];
        apiLivePrices = data.livePrices || {};
      }
    } catch(e) {
      console.log('Proxy API failed, trying direct...');
    }
    
    // Also try fetching prices directly if not from API
    if (Object.keys(apiLivePrices).length <= 1) {
      try {
        const pr = await fetch('/api/prices');
        if (pr.ok) apiLivePrices = await pr.json();
      } catch(e) {}
    }
    
    // Fallback: try direct API (works if CORS allows)
    if (markets.length === 0) {
      try {
        const res = await fetch(GAMMA_API + '?closed=false&limit=100&order=volume24hr&ascending=false');
        if (res.ok) markets = await res.json();
      } catch(e) {}
    }
    
    // Fallback: CORS proxy
    if (markets.length === 0) {
      try {
        const res = await fetch(CORS_PROXY + encodeURIComponent(GAMMA_API + '?closed=false&limit=100&order=volume24hr&ascending=false'));
        if (res.ok) markets = await res.json();
      } catch(e) {}
    }

    if (markets.length === 0) {
      markets = EMBEDDED_MARKETS;
      document.querySelector('.status-badge').textContent = 'Cached Data';
      document.querySelector('.status-badge').style.background = '#f59e0b33';
      document.querySelector('.status-badge').style.color = '#f59e0b';
    } else {
      document.querySelector('.status-badge').innerHTML = '<span class="live-dot"></span> Live Data';
      document.querySelector('.status-badge').style.background = 'var(--green-dim)';
      document.querySelector('.status-badge').style.color = 'var(--green)';
    }
    
    // Store live prices and render ticker
    if (apiLivePrices && Object.keys(apiLivePrices).length > 0) {
      livePrices = apiLivePrices;
      renderPriceTicker();
    }

    // Dedupe by id
    const seen = new Set();
    markets = markets.filter(m => { if (seen.has(m.id)) return false; seen.add(m.id); return true; });

    // Filter to markets with meaningful data
    const validMarkets = markets.filter(m => {
      if (!m.outcomePrices || !m.question) return false;
      try {
        const price = parseFloat(JSON.parse(m.outcomePrices)[0]);
        return price > 0 && price < 1 && m.active && !m.closed;
      } catch(e) { return false; }
    });

    totalScanned = validMarkets.length;
    
    // Cross-market consistency: group by negRiskMarketID
    crossMarketGroups = {};
    for (const m of validMarkets) {
      const gid = m.negRiskMarketID;
      if (gid) {
        if (!crossMarketGroups[gid]) crossMarketGroups[gid] = [];
        try {
          const p = parseFloat(JSON.parse(m.outcomePrices)[0]);
          crossMarketGroups[gid].push({ id: m.id, question: m.question, yesPrice: p });
        } catch(e) {}
      }
    }
    // Calculate group sums and flag inconsistencies
    const crossMarketFlags = {};
    for (const [gid, items] of Object.entries(crossMarketGroups)) {
      if (items.length < 2) continue;
      const sum = items.reduce((s, i) => s + i.yesPrice, 0);
      const deviation = Math.abs(sum - 1.0);
      if (deviation > 0.03) { // >3% off from 100%
        for (const item of items) {
          crossMarketFlags[item.id] = {
            groupId: gid,
            groupSize: items.length,
            groupSum: sum,
            deviation,
            signal: `Cross-market inconsistency: ${items.length} outcomes sum to ${(sum*100).toFixed(1)}% instead of ~100%`
          };
        }
      }
    }
    
    allOpportunities = validMarkets.map(m => {
      const o = analyzeMarket(m);
      // Attach cross-market flag
      if (crossMarketFlags[o.id]) {
        o.crossMarketFlag = crossMarketFlags[o.id];
      }
      // Attach live price analysis
      if (m.relevantLivePrice) {
        o.relevantLivePrice = m.relevantLivePrice;
        const priceNote = generateLivePriceNote(o.question, m.relevantLivePrice);
        if (priceNote) {
          o.livePriceNote = priceNote;
          o.reasoning = priceNote.html + o.reasoning;
        }
      }
      return o;
    })
      .filter(o => o.edge > 0.001)
      .sort((a,b) => b.edge - a.edge);

    document.getElementById('lastUpdated').textContent = 'Updated: ' + new Date().toLocaleString();
    renderDashboard();
    if (currentView === 'top10') {
      renderTop10();
    } else {
      renderGrid();
    }
    buildCategoryFilters();
  } catch(err) {
    document.getElementById('grid').innerHTML = `<div class="loading">Error loading markets: ${err.message}</div>`;
  }
}

// Embedded fallback data (snapshot from API)
const EMBEDDED_MARKETS = [
  {id:"1308327",question:"Government shutdown on Saturday?",slug:"another-us-government-shutdown-by-february-14",description:"Resolves Yes if OPM announces new federal shutdown by Feb 14",outcomePrices:'["0.129","0.871"]',volume:"9152678",active:true,closed:false,volumeNum:9152678,liquidityNum:74570,endDate:"2026-02-14T00:00:00Z",volume24hr:5932125,spread:0.002,oneDayPriceChange:-0.831,oneWeekPriceChange:-0.534,bestBid:0.128,bestAsk:0.13,image:""},
  {id:"572473",question:"Will Trump nominate Judy Shelton as the next Fed chair?",slug:"will-trump-nominate-judy-shelton-as-the-next-fed-chair",description:"Resolves per formal nomination to Senate",outcomePrices:'["0.0265","0.9735"]',volume:"80172955",active:true,closed:false,volumeNum:80172955,liquidityNum:3181493,endDate:"2026-12-31T00:00:00Z",volume24hr:2882914,spread:0.001,oneDayPriceChange:-0.017,oneWeekPriceChange:0,bestBid:0.026,bestAsk:0.027,image:""},
  {id:"1303357",question:"Will Ethereum reach $4,400 in February?",slug:"will-ethereum-reach-4400-in-february-2026",description:"Resolves if any Binance 1m candle for ETH/USDT hits $4400",outcomePrices:'["0.0025","0.9975"]',volume:"6312650",active:true,closed:false,volumeNum:6312650,liquidityNum:526830,endDate:"2026-03-01T05:00:00Z",volume24hr:2783980,spread:0.001,oneDayPriceChange:0,oneWeekPriceChange:0,bestBid:0.002,bestAsk:0.003,image:""},
  {id:"1273610",question:"US strikes Iran by February 13, 2026?",slug:"us-strikes-iran-by-february-13-2026",description:"Resolves Yes if US strikes on Iranian soil",outcomePrices:'["0.0055","0.9945"]',volume:"14050697",active:true,closed:false,volumeNum:14050697,liquidityNum:220110,endDate:"2026-02-14T00:00:00Z",volume24hr:1828393,spread:0.001,oneDayPriceChange:-0.003,oneWeekPriceChange:-0.1095,bestBid:0.005,bestAsk:0.006,image:""},
  {id:"654412",question:"Will the Fed decrease interest rates by 50+ bps after the March 2026 meeting?",slug:"fed-50bps-decrease-march-2026",description:"Resolves per FOMC March 2026 statement",outcomePrices:'["0.0065","0.9935"]',volume:"39795139",active:true,closed:false,volumeNum:39795139,liquidityNum:1524654,endDate:"2026-03-18T00:00:00Z",volume24hr:1723031,spread:0.001,oneDayPriceChange:0,oneWeekPriceChange:-0.004,bestBid:0.006,bestAsk:0.007,image:""},
  {id:"654414",question:"Will there be no change in Fed interest rates after the March 2026 meeting?",slug:"fed-no-change-march-2026",description:"Resolves per FOMC March 2026 statement",outcomePrices:'["0.925","0.075"]',volume:"14298890",active:true,closed:false,volumeNum:14298890,liquidityNum:1012712,endDate:"2026-03-18T00:00:00Z",volume24hr:1624556,spread:0.001,oneDayPriceChange:0,oneWeekPriceChange:0,bestBid:0.92,bestAsk:0.93,image:""}
];

// ============================================
// RENDERING
// ============================================

function renderDashboard() {
  const ops = allOpportunities;
  const avgEdge = ops.length ? ops.reduce((s,o) => s+o.edge, 0) / ops.length : 0;
  const avgReturn = ops.length ? ops.reduce((s,o) => s+o.returnPct, 0) / ops.length : 0;
  const best = ops[0];
  const catCounts = {};
  ops.forEach(o => { catCounts[o.category] = (catCounts[o.category]||0) + 1; });

  let catDotsHtml = Object.entries(catCounts).map(([c,n]) => 
    `<div class="cat-dot"><i style="background:${CATEGORIES[c]?.color||'#888'}"></i>${CATEGORIES[c]?.label||c} (${n})</div>`
  ).join('');

  document.getElementById('dashboard').innerHTML = `
    <div class="dash-card">
      <div class="label">Opportunities Found</div>
      <div class="value">${ops.length}</div>
      <div class="sub">From ${totalScanned} markets scanned</div>
    </div>
    <div class="dash-card">
      <div class="label">Average Return</div>
      <div class="value green">+${(avgReturn*100).toFixed(1)}%</div>
      <div class="sub">ROI on entry price</div>
    </div>
    <div class="dash-card highlight">
      <div class="label">Best Opportunity</div>
      <div class="value green" style="font-size:18px">${best ? '+' + (best.returnPct*100).toFixed(1) + '% ROI' : 'N/A'}</div>
      <div class="sub">${best ? best.question.slice(0,50) + '...' : ''}</div>
    </div>
    <div class="dash-card">
      <div class="label">Category Breakdown</div>
      <div class="cat-chart">${catDotsHtml}</div>
    </div>
  `;
}

function buildCategoryFilters() {
  const cats = [...new Set(allOpportunities.map(o => o.category))];
  document.getElementById('catFilters').innerHTML = 
    `<button class="btn active" data-cat="all">All</button>` +
    cats.map(c => `<button class="btn" data-cat="${c}">${CATEGORIES[c]?.label||c}</button>`).join('');
  
  document.querySelectorAll('#catFilters .btn').forEach(btn => {
    btn.addEventListener('click', () => {
      document.querySelectorAll('#catFilters .btn').forEach(b => b.classList.remove('active'));
      btn.classList.add('active');
      activeCategory = btn.dataset.cat;
      renderGrid();
    });
  });
}

function getFilteredSorted() {
  let ops = [...allOpportunities];
  
  // Category filter
  if (activeCategory !== 'all') ops = ops.filter(o => o.category === activeCategory);
  
  // Search
  const search = document.getElementById('searchBox').value.toLowerCase();
  if (search) ops = ops.filter(o => o.question.toLowerCase().includes(search));
  
  // Confidence filter
  const minConf = document.getElementById('minConfidence').value;
  if (minConf === 'high') ops = ops.filter(o => o.confidence === 'high');
  if (minConf === 'medium') ops = ops.filter(o => o.confidence === 'high' || o.confidence === 'medium');
  
  // Sort
  const sort = document.getElementById('sortBy').value;
  ops.sort((a,b) => {
    if (sort === 'edge') return b.returnPct - a.returnPct;
    if (sort === 'confidence') return confVal(b.confidence) - confVal(a.confidence) || b.edge - a.edge;
    if (sort === 'liquidity') return b.liquidity - a.liquidity;
    if (sort === 'resolution') return a.daysLeft - b.daysLeft;
    if (sort === 'volume') return b.volume24h - a.volume24h;
    return 0;
  });
  
  return ops;
}

function confVal(c) { return c === 'high' ? 3 : c === 'medium' ? 2 : 1; }
function confBadge(c) {
  if (c === 'high') return 'üü¢ High';
  if (c === 'medium') return 'üü° Medium';
  return 'üî¥ Low';
}
function liqIndicator(s) { return 'üíß'.repeat(s); }

function renderGrid() {
  const ops = getFilteredSorted();
  if (!ops.length) {
    document.getElementById('grid').innerHTML = '<div class="loading">No opportunities match your filters</div>';
    return;
  }

  document.getElementById('grid').innerHTML = ops.map(o => {
    const edgeClass = o.edge > 0 ? 'pos' : 'neg';
    const catInfo = CATEGORIES[o.category] || { label: o.category, class: 'tag-politics' };
    const barWidth = Math.min(100, o.returnPct * 100 * 2); // Scale for visibility
    const barColor = o.direction.includes('YES') ? 'var(--green)' : 'var(--accent)';
    
    return `
    <div class="card" onclick="openModal('${o.id}')">
      <div class="card-top">
        <div class="card-title">${o.question}</div>
        <div class="card-edge ${edgeClass}">${o.deepAnalysis ? 'üî• ' : ''}+${(o.returnPct*100).toFixed(1)}% ROI</div>
      </div>
      <div class="card-meta">
        <span class="tag ${catInfo.class}">${catInfo.label}</span>
        <span class="confidence">${confBadge(o.confidence)}</span>
        <span class="liquidity">${liqIndicator(o.liqScore)}</span>
      </div>
      <div class="card-prices">
        <div class="price-group">
          <span class="price-label">Market</span>
          <span class="price-val">${(o.marketPrice*100).toFixed(1)}¬¢</span>
        </div>
        <div class="price-group">
          <span class="price-label">Model</span>
          <span class="price-val" style="color:var(--green)">${(o.modelEstimate*100).toFixed(1)}¬¢</span>
        </div>
        <div class="price-group">
          <span class="price-label">Action</span>
          <span class="price-val" style="color:${o.direction.includes('YES') ? 'var(--green)' : 'var(--accent)'}">${o.direction}</span>
        </div>
      </div>
      <div class="card-bar"><div class="card-bar-fill" style="width:${barWidth}%;background:${barColor}"></div></div>
      ${o.livePriceNote ? `<div class="live-price-note" style="margin-bottom:8px">üíπ ${o.relevantLivePrice.asset}: $${o.relevantLivePrice.price.toLocaleString(undefined,{maximumFractionDigits:o.relevantLivePrice.price>=100?0:2})}</div>` : ''}
      <div class="card-bottom">
        <div class="card-resolution">‚è± ${o.eventWindowPassed ? '‚è∞ Event passed' : o.daysLeft === 0 ? 'Today' : o.daysLeft + 'd left'}${o.news ? ' üì∞' : ''}${o.crossMarketFlag ? ' üîó' : ''}</div>
        <div>Vol: ${formatMoney(o.volume24h)}/24h</div>
      </div>
    </div>`;
  }).join('');
}

function openModal(id) {
  const o = allOpportunities.find(x => x.id === id);
  if (!o) return;
  const catInfo = CATEGORIES[o.category] || { label: o.category, class: 'tag-politics' };
  
  document.getElementById('modal').innerHTML = `
    <button class="modal-close" onclick="closeModal()">&times;</button>
    <div class="card-meta" style="margin-bottom:12px">
      <span class="tag ${catInfo.class}">${catInfo.label}</span>
      <span class="confidence">${confBadge(o.confidence)}</span>
      <span class="liquidity">${liqIndicator(o.liqScore)}</span>
    </div>
    <h2>${o.question}</h2>
    
    <div class="modal-section">
      <h3>üìä Price Comparison</h3>
      <div class="modal-prices">
        <div class="modal-price-box">
          <div class="lbl">Market Price (Yes)</div>
          <div class="val">${(o.marketPrice*100).toFixed(1)}¬¢</div>
        </div>
        <div class="modal-price-box">
          <div class="lbl">Model Estimate</div>
          <div class="val green">${(o.modelEstimate*100).toFixed(1)}¬¢</div>
        </div>
        <div class="modal-price-box">
          <div class="lbl">Edge</div>
          <div class="val blue">+${(o.edge*100).toFixed(1)}%</div>
        </div>
        <div class="modal-price-box">
          <div class="lbl">Return (ROI)</div>
          <div class="val green">+${(o.returnPct*100).toFixed(1)}%</div>
        </div>
      </div>
      <div class="compare-bar">
        <div class="fill" style="width:${(o.modelEstimate*100)}%"></div>
        <div class="market-line" style="left:${(o.marketPrice*100)}%"></div>
        <div class="model-line" style="left:${(o.modelEstimate*100)}%"></div>
      </div>
      <div class="compare-labels">
        <span>0%</span>
        <span style="color:var(--red)">‚ñ≤ Market ${(o.marketPrice*100).toFixed(1)}%</span>
        <span style="color:var(--green)">‚ñ≤ Model ${(o.modelEstimate*100).toFixed(1)}%</span>
        <span>100%</span>
      </div>
    </div>

    <div class="modal-section">
      <h3>üìê Edge Breakdown</h3>
      <div class="edge-breakdown">
        <div class="edge-row"><span class="el">Market Yes Price</span><span>${(o.marketPrice*100).toFixed(2)}¬¢</span></div>
        <div class="edge-row"><span class="el">Model Fair Value</span><span>${(o.modelEstimate*100).toFixed(2)}¬¢</span></div>
        <div class="edge-row"><span class="el">Raw Edge</span><span style="color:var(--green)">+${(o.edge*100).toFixed(2)}%</span></div>
        <div class="edge-row"><span class="el">Return (ROI)</span><span style="color:var(--green);font-weight:700">+${(o.returnPct*100).toFixed(1)}%</span></div>
        <div class="edge-row"><span class="el">Entry Price</span><span>${(o.entryPrice*100).toFixed(2)}¬¢</span></div>
        <div class="edge-row"><span class="el">Recommended Action</span><span style="color:var(--accent);font-weight:700">${o.direction}</span></div>
        <div class="edge-row"><span class="el">Bid / Ask</span><span>${o.bestBid || '‚Äî'} / ${o.bestAsk || '‚Äî'}</span></div>
        <div class="edge-row"><span class="el">Spread</span><span>${(o.spread*100).toFixed(1)}%</span></div>
      </div>
    </div>

    ${o.crossMarketFlag ? `
    <div class="modal-section" style="border:1px solid #a855f744;border-radius:12px;padding:16px;background:#a855f708">
      <h3>üîó Cross-Market Consistency</h3>
      <div class="analysis-text">
        <p><strong>${o.crossMarketFlag.signal}</strong></p>
        <p>This market is part of a group of ${o.crossMarketFlag.groupSize} mutually exclusive outcomes. Their YES prices sum to <strong>${(o.crossMarketFlag.groupSum*100).toFixed(1)}%</strong> instead of the expected ~100%. This ${o.crossMarketFlag.deviation > 0.05 ? '<strong>significant</strong>' : 'minor'} deviation of ${(o.crossMarketFlag.deviation*100).toFixed(1)}pp suggests mispricing within this group.</p>
      </div>
    </div>` : ''}

    <div class="modal-section">
      <h3>üß† Why We Think This</h3>
      <div class="analysis-text">${o.reasoning}</div>
    </div>

    ${o.deepAnalysis ? `
    <div class="modal-section" style="border:1px solid #f59e0b44;border-radius:12px;padding:20px;background:#f59e0b08">
      <h3>üî• Deep Analysis <span style="font-size:11px;font-weight:400;color:var(--orange)">(${(o.returnPct*100).toFixed(0)}% ROI opportunity)</span></h3>
      <div class="analysis-text">
        <p><strong>Why we see edge:</strong> ${o.deepAnalysis.whyEdge}</p>
        <p><strong>Risk factors:</strong></p>
        <ul style="margin:0 0 12px 20px;color:var(--text-dim)">${o.deepAnalysis.risks.map(r => '<li>' + r + '</li>').join('')}</ul>
        <p><strong>Position sizing:</strong> ${o.deepAnalysis.sizingHint}</p>
        <p><strong>üîë Key question:</strong> <em>${o.deepAnalysis.keyQuestion}</em></p>
      </div>
    </div>` : ''}

    ${o.newsSignals && o.newsSignals.hasNews ? `
    <div class="modal-section">
      <h3>üì∞ News Signals</h3>
      <div class="edge-breakdown">
        ${o.newsSignals.signals.map(s => `
          <div class="edge-row" style="flex-direction:column;gap:4px;padding:10px 0">
            <div style="display:flex;justify-content:space-between;align-items:flex-start;gap:8px">
              <a href="${s.url}" target="_blank" style="font-size:13px;line-height:1.4;flex:1">${s.title}</a>
              <span style="white-space:nowrap;font-size:11px;padding:2px 6px;border-radius:4px;background:${s.label==='bullish'?'var(--green-dim)':s.label==='bearish'?'var(--red-dim)':'var(--border)'};color:${s.label==='bullish'?'var(--green)':s.label==='bearish'?'var(--red)':'var(--text-dim)'}">${s.label === 'bullish' ? '‚ñ≤ YES' : s.label === 'bearish' ? '‚ñº NO' : '‚Äî Neutral'}</span>
            </div>
            <div style="font-size:11px;color:var(--text-muted)">${s.source}${s.hoursAgo !== undefined ? ` ¬∑ ${s.hoursAgo < 1 ? 'just now' : s.hoursAgo + 'h ago'}` : ''} ¬∑ Weight: ${(s.weight*100).toFixed(0)}%</div>
          </div>
        `).join('')}
        <div class="edge-row" style="font-weight:600">
          <span class="el">Net News Sentiment</span>
          <span style="color:${o.newsSignals.avgSentiment > 0 ? 'var(--green)' : o.newsSignals.avgSentiment < 0 ? 'var(--red)' : 'var(--text-dim)'}">
            ${o.newsSignals.avgSentiment > 0 ? '‚ñ≤ Bullish' : o.newsSignals.avgSentiment < 0 ? '‚ñº Bearish' : '‚Äî Neutral'} (${(o.newsSignals.adjustment*100).toFixed(1)}pp adjustment)
          </span>
        </div>
      </div>
    </div>` : ''}

    <div class="modal-section">
      <h3>üìà Market Stats</h3>
      <div class="modal-stats">
        <div class="stat-box"><div class="sl">24h Volume</div>${formatMoney(o.volume24h)}</div>
        <div class="stat-box"><div class="sl">Total Volume</div>${formatMoney(o.totalVolume)}</div>
        <div class="stat-box"><div class="sl">Liquidity</div>${formatMoney(o.liquidity)}</div>
        <div class="stat-box"><div class="sl">Days to Resolution</div>${o.daysLeft === 0 ? 'Today' : o.daysLeft + ' days'}</div>
        <div class="stat-box"><div class="sl">1-Day Change</div><span style="color:${(o.oneDayChange||0) >= 0 ? 'var(--green)' : 'var(--red)'}">${((o.oneDayChange||0)*100).toFixed(1)}¬¢</span></div>
        <div class="stat-box"><div class="sl">1-Week Change</div><span style="color:${(o.oneWeekChange||0) >= 0 ? 'var(--green)' : 'var(--red)'}">${((o.oneWeekChange||0)*100).toFixed(1)}¬¢</span></div>
      </div>
    </div>

    <a class="modal-link" href="https://polymarket.com/event/${o.slug}" target="_blank">
      View on Polymarket ‚Üí
    </a>
    <div class="modal-ts">Analysis generated: ${new Date().toLocaleString()}</div>
  `;
  
  document.getElementById('modalOverlay').classList.add('open');
  document.body.style.overflow = 'hidden';
}

function closeModal() {
  document.getElementById('modalOverlay').classList.remove('open');
  document.body.style.overflow = '';
}

document.getElementById('modalOverlay').addEventListener('click', e => {
  if (e.target === e.currentTarget) closeModal();
});
document.addEventListener('keydown', e => { if (e.key === 'Escape') closeModal(); });

// ============================================
// LIVE PRICE INTEGRATION
// ============================================

function renderPriceTicker() {
  const el = document.getElementById('priceTicker');
  if (!livePrices || Object.keys(livePrices).length <= 1) {
    el.style.display = 'none';
    return;
  }
  el.style.display = 'flex';
  const items = [];
  const map = { btc: '‚Çø BTC', eth: 'Œû ETH', sol: '‚óé SOL', xrp: 'XRP', sp500: 'üìà S&P 500', gold: 'ü•á Gold' };
  for (const [key, label] of Object.entries(map)) {
    const d = livePrices[key];
    if (!d || !d.price) continue;
    const ch = d.change24h || 0;
    const chClass = ch >= 0 ? 'up' : 'down';
    const chSign = ch >= 0 ? '+' : '';
    const priceStr = d.price >= 1000 ? '$' + d.price.toLocaleString(undefined, {maximumFractionDigits: 0}) : '$' + d.price.toFixed(2);
    let extra = '';
    if (key === 'sp500' && d.marketOpen !== undefined) {
      extra = `<span style="font-size:10px;color:${d.marketOpen ? 'var(--green)' : 'var(--text-muted)'}"> ${d.marketOpen ? '‚óè Open' : '‚óè Closed'}</span>`;
    }
    items.push(`<div class="ticker-item"><span class="ticker-asset">${label}</span><span class="ticker-price">${priceStr}</span><span class="ticker-change ${chClass}">${chSign}${ch.toFixed(2)}%</span>${extra}</div>`);
  }
  el.innerHTML = items.join('<span style="color:var(--border)">|</span>');
}

function generateLivePriceNote(question, livePrice) {
  if (!livePrice || !livePrice.price) return null;
  const ql = question.toLowerCase();
  
  // Extract price target from question
  const targetMatch = question.match(/\$?([\d,]+(?:\.\d+)?)\s*[kK]?/);
  if (!targetMatch) return null;
  
  let target = parseFloat(targetMatch[1].replace(/,/g, ''));
  if (/\d+[kK]/.test(question)) target *= 1000;
  if (target < 1) return null;
  
  const current = livePrice.price;
  const pctMove = ((target - current) / current) * 100;
  const direction = pctMove > 0 ? 'gain' : 'drop';
  const asset = livePrice.asset;
  
  let extra = '';
  if (livePrice.marketOpen !== undefined) {
    extra = ` Market is currently ${livePrice.marketOpen ? 'open' : 'closed'}.`;
  }
  
  return {
    text: `${asset} is currently at $${current.toLocaleString(undefined, {maximumFractionDigits: current >= 100 ? 0 : 2})} ‚Äî reaching $${target.toLocaleString()} requires a ${pctMove > 0 ? '+' : ''}${pctMove.toFixed(1)}% ${direction}.${extra}`,
    html: `<p class="live-price-note">üíπ <strong>${asset}</strong> is currently at <strong>$${current.toLocaleString(undefined, {maximumFractionDigits: current >= 100 ? 0 : 2})}</strong> ‚Äî reaching $${target.toLocaleString()} requires a <strong>${pctMove > 0 ? '+' : ''}${pctMove.toFixed(1)}% ${direction}</strong>.${extra}</p>`,
    pctMove,
    current,
    target
  };
}

// ============================================
// TOP 10 OPPORTUNITIES
// ============================================

function computeCompositeScore(o) {
  // ROI (30%)
  const roiScore = Math.min(1, o.returnPct / 2); // cap at 200% ROI = 1.0
  
  // Confidence (25%)
  const confScore = o.confidence === 'high' ? 1.0 : o.confidence === 'medium' ? 0.6 : 0.2;
  
  // News signal strength (20%)
  let newsScore = 0.3; // default: no news = neutral
  if (o.newsSignals && o.newsSignals.hasNews) {
    newsScore = Math.min(1, 0.3 + Math.abs(o.newsSignals.avgSentiment) * 0.7 + (o.newsSignals.agreementLevel >= 3 ? 0.2 : 0));
  }
  
  // Liquidity (15%)
  const liqScore = o.liqScore === 3 ? 1.0 : o.liqScore === 2 ? 0.6 : 0.2;
  
  // Cross-market edge (10%)
  let crossScore = 0;
  if (o.crossMarketFlag) {
    crossScore = Math.min(1, o.crossMarketFlag.deviation * 5); // 20% deviation = 1.0
  }
  
  return roiScore * 0.30 + confScore * 0.25 + newsScore * 0.20 + liqScore * 0.15 + crossScore * 0.10;
}

function showTop10() {
  currentView = 'top10';
  document.getElementById('btnTop10').classList.add('btn-primary');
  document.getElementById('btnTop10').style.opacity = '1';
  document.getElementById('btnAllMarkets').classList.remove('active');
  document.getElementById('grid').style.display = 'none';
  document.getElementById('top10List').style.display = 'flex';
  document.querySelector('.controls').style.display = 'none';
  renderTop10();
}

function showAllMarkets() {
  currentView = 'all';
  document.getElementById('btnAllMarkets').classList.add('active');
  document.getElementById('grid').style.display = 'grid';
  document.getElementById('top10List').style.display = 'none';
  document.querySelector('.controls').style.display = 'flex';
  document.getElementById('viewLabel').textContent = '';
  renderGrid();
}

function renderTop10() {
  const scored = allOpportunities.map(o => ({...o, compositeScore: computeCompositeScore(o)}));
  scored.sort((a, b) => b.compositeScore - a.compositeScore);
  const top10 = scored.slice(0, 10);
  
  document.getElementById('viewLabel').textContent = `Showing top 10 of ${allOpportunities.length} opportunities`;
  
  if (top10.length === 0) {
    document.getElementById('top10List').innerHTML = '<div class="loading">No opportunities found yet...</div>';
    return;
  }
  
  document.getElementById('top10List').innerHTML = top10.map((o, i) => {
    const rankClass = i === 0 ? 'gold' : i === 1 ? 'silver' : i === 2 ? 'bronze' : '';
    const catInfo = CATEGORIES[o.category] || { label: o.category, class: 'tag-politics' };
    const actionClass = o.direction.includes('YES') ? 'buy-yes' : 'buy-no';
    
    // Generate brief reasoning
    let brief = '';
    if (o.livePriceNote) brief += o.livePriceNote.text + ' ';
    if (o.crossMarketFlag) brief += o.crossMarketFlag.signal + '. ';
    if (o.newsSignals && o.newsSignals.hasNews) {
      const dir = o.newsSignals.avgSentiment > 0 ? 'bullish' : o.newsSignals.avgSentiment < 0 ? 'bearish' : 'neutral';
      brief += `News sentiment: ${dir}. `;
    }
    if (!brief) {
      brief = o.confidence === 'high' ? 'High confidence edge with good liquidity.' :
              o.confidence === 'medium' ? 'Medium confidence ‚Äî thesis supported by multiple signals.' :
              'Speculative opportunity with asymmetric payoff.';
    }
    
    return `
    <div class="ranked-item" onclick="openModal('${o.id}')">
      <div class="rank-badge ${rankClass}">#${i+1}</div>
      <div class="ranked-body">
        <div class="ranked-title">${o.question}</div>
        <div class="ranked-scores">
          <span class="tag ${catInfo.class}">${catInfo.label}</span>
          <span class="score-pill"><strong>${confBadge(o.confidence)}</strong></span>
          <span class="score-pill">üíß ${liqIndicator(o.liqScore)}</span>
          <span class="score-pill">Score: <strong>${(o.compositeScore * 100).toFixed(0)}</strong></span>
          ${o.crossMarketFlag ? '<span class="cross-market-flag">üîó Cross-market</span>' : ''}
          ${o.news ? '<span class="score-pill">üì∞ News</span>' : ''}
        </div>
        <div class="ranked-reasoning">${brief}</div>
        ${o.livePriceNote ? `<div class="live-price-note">üíπ ${o.relevantLivePrice.asset}: $${o.relevantLivePrice.price.toLocaleString()}</div>` : ''}
      </div>
      <div class="ranked-right">
        <div class="ranked-roi">+${(o.returnPct*100).toFixed(1)}%</div>
        <div class="ranked-action ${actionClass}">${o.direction}</div>
        <div style="font-size:11px;color:var(--text-muted)">${o.daysLeft}d left</div>
      </div>
    </div>`;
  }).join('');
}

// Event listeners for filters
['searchBox'].forEach(id => document.getElementById(id).addEventListener('input', renderGrid));
['sortBy', 'minConfidence'].forEach(id => document.getElementById(id).addEventListener('change', renderGrid));

// Init ‚Äî default to Top 10 view
currentView = 'top10';
document.getElementById('grid').style.display = 'none';
document.getElementById('top10List').style.display = 'flex';
document.querySelector('.controls').style.display = 'none';
document.getElementById('btnAllMarkets').classList.remove('active');
fetchMarkets();
// Auto-refresh every 60 seconds
setInterval(fetchMarkets, 60000);


// ============================================
// MOCK TRADING SYSTEM
// ============================================

const PORTFOLIO_KEY = 'polymarket_mock_portfolio';
const SNAPSHOTS_KEY = 'polymarket_portfolio_snapshots';

function getPortfolio() {
  const raw = localStorage.getItem(PORTFOLIO_KEY);
  if (raw) return JSON.parse(raw);
  return { trades: [], portfolioValue: 10000, cashBalance: 10000 };
}

function savePortfolio(p) {
  localStorage.setItem(PORTFOLIO_KEY, JSON.stringify(p));
  updatePortfolioSummaryBar();
}

function getSnapshots() {
  const raw = localStorage.getItem(SNAPSHOTS_KEY);
  return raw ? JSON.parse(raw) : [];
}

function saveSnapshot(value) {
  const snaps = getSnapshots();
  snaps.push({ time: new Date().toISOString(), value });
  if (snaps.length > 500) snaps.splice(0, snaps.length - 500);
  localStorage.setItem(SNAPSHOTS_KEY, JSON.stringify(snaps));
}

function generateTradeId() {
  return 'xxxx-xxxx'.replace(/x/g, () => Math.floor(Math.random()*16).toString(16));
}

function calcPortfolioValue(p) {
  let openValue = 0;
  for (const t of p.trades) {
    if (t.status === 'open') openValue += t.shares * (t.currentPrice || t.entryPrice);
  }
  return p.cashBalance + openValue;
}

function updateOpenPrices() {
  const p = getPortfolio();
  let changed = false;
  for (const t of p.trades) {
    if (t.status !== 'open') continue;
    const opp = allOpportunities.find(o => o.id === t.marketId);
    if (opp) {
      const newPrice = t.direction === 'BUY YES' ? opp.marketPrice : (1 - opp.marketPrice);
      if (newPrice !== t.currentPrice) { t.currentPrice = newPrice; changed = true; }
    }
  }
  if (changed) {
    p.portfolioValue = calcPortfolioValue(p);
    savePortfolio(p);
    saveSnapshot(p.portfolioValue);
  }
}

function switchTab(tab) {
  document.querySelectorAll('.tab-btn').forEach(b => b.classList.toggle('active', b.dataset.tab === tab));
  document.querySelectorAll('.tab-content').forEach(el => el.classList.toggle('active', el.id === 'tab-' + tab));
  if (tab === 'portfolio') renderPortfolio();
}

function updatePortfolioSummaryBar() {
  const p = getPortfolio();
  const val = calcPortfolioValue(p);
  const pnl = val - 10000;
  const pnlPct = (pnl / 10000 * 100).toFixed(1);
  const color = pnl >= 0 ? 'var(--green)' : 'var(--red)';
  const sign = pnl >= 0 ? '+' : '';
  const el = document.getElementById('portfolioSummaryBar');
  if (el) el.innerHTML = '\u{1f4c8} Portfolio: <span style="color:' + color + '">$' + val.toFixed(0) + ' (' + sign + pnlPct + '%)</span>';
}

function openTradeForm(pf) {
  pf = pf || {};
  document.getElementById('tradeForm').innerHTML = '<button class="modal-close" onclick="closeTradeForm()">&times;</button>' +
    '<h3>\u{1f4dd} Open Mock Trade</h3>' +
    '<label>Market Question</label>' +
    '<input type="text" id="tf_question" value="' + (pf.question||'').replace(/"/g,'&quot;') + '" placeholder="e.g. Will BTC hit $84K?">' +
    '<input type="hidden" id="tf_marketId" value="' + (pf.marketId||'') + '">' +
    '<label>Direction</label>' +
    '<select id="tf_direction"><option value="BUY YES"' + (pf.direction==='BUY YES'?' selected':'') + '>BUY YES</option><option value="BUY NO"' + (pf.direction==='BUY NO'?' selected':'') + '>BUY NO</option></select>' +
    '<label>Position Size ($)</label>' +
    '<input type="number" id="tf_size" value="' + (pf.size||100) + '" min="1" step="1">' +
    '<label>Entry Price (\u00a2 per share)</label>' +
    '<input type="number" id="tf_price" value="' + ((pf.entryPrice||0.5)*100).toFixed(1) + '" min="0.1" max="99.9" step="0.1">' +
    '<label>Reasoning</label>' +
    '<textarea id="tf_reasoning">' + (pf.reasoning||'') + '</textarea>' +
    '<div class="trade-form-actions"><button class="btn-cancel" onclick="closeTradeForm()">Cancel</button><button class="btn-confirm" onclick="confirmTrade()">Open Position</button></div>';
  document.getElementById('tradeFormOverlay').classList.add('open');
}

function closeTradeForm() {
  document.getElementById('tradeFormOverlay').classList.remove('open');
}

document.getElementById('tradeFormOverlay').addEventListener('click', function(e) {
  if (e.target === e.currentTarget) closeTradeForm();
});

function confirmTrade() {
  const question = document.getElementById('tf_question').value.trim();
  if (!question) return alert('Enter a market question');
  const marketId = document.getElementById('tf_marketId').value || question;
  const direction = document.getElementById('tf_direction').value;
  const size = parseFloat(document.getElementById('tf_size').value);
  const entryPrice = parseFloat(document.getElementById('tf_price').value) / 100;
  const reasoning = document.getElementById('tf_reasoning').value;
  if (isNaN(size) || size <= 0) return alert('Invalid position size');
  if (isNaN(entryPrice) || entryPrice <= 0 || entryPrice >= 1) return alert('Invalid entry price');
  const p = getPortfolio();
  if (size > p.cashBalance) return alert('Insufficient cash. Available: $' + p.cashBalance.toFixed(2));
  const shares = size / entryPrice;
  p.trades.push({
    id: generateTradeId(), marketId, question, direction, entryPrice,
    entryTime: new Date().toISOString(), shares, currentPrice: entryPrice,
    status: 'open', exitPrice: null, exitTime: null, pnl: null, reasoning
  });
  p.cashBalance -= size;
  p.portfolioValue = calcPortfolioValue(p);
  savePortfolio(p);
  saveSnapshot(p.portfolioValue);
  closeTradeForm();
  if (document.getElementById('tab-portfolio').classList.contains('active')) renderPortfolio();
}

function closePosition(tradeId) {
  const p = getPortfolio();
  const t = p.trades.find(x => x.id === tradeId);
  if (!t || t.status !== 'open') return;
  t.exitPrice = t.currentPrice;
  t.exitTime = new Date().toISOString();
  t.pnl = (t.exitPrice - t.entryPrice) * t.shares;
  t.status = 'closed';
  p.cashBalance += t.shares * t.exitPrice;
  p.portfolioValue = calcPortfolioValue(p);
  savePortfolio(p);
  saveSnapshot(p.portfolioValue);
  renderPortfolio();
}

function formatTimeHeld(isoStart, isoEnd) {
  const ms = (isoEnd ? new Date(isoEnd) : new Date()) - new Date(isoStart);
  const mins = Math.floor(ms / 60000);
  if (mins < 60) return mins + 'm';
  const hrs = Math.floor(mins / 60);
  if (hrs < 24) return hrs + 'h ' + (mins % 60) + 'm';
  return Math.floor(hrs / 24) + 'd ' + (hrs % 24) + 'h';
}

function renderPortfolio() {
  const p = getPortfolio();
  const val = calcPortfolioValue(p);
  const totalPnl = val - 10000;
  const totalPnlPct = (totalPnl / 10000 * 100).toFixed(1);
  const openTrades = p.trades.filter(t => t.status === 'open');
  const closedTrades = p.trades.filter(t => t.status === 'closed');
  const wins = closedTrades.filter(t => t.pnl > 0).length;
  const winRate = closedTrades.length > 0 ? ((wins / closedTrades.length) * 100).toFixed(0) : '\u2014';

  document.getElementById('portfolioDashboard').innerHTML =
    '<div class="dash-card"><div class="label">Starting Balance</div><div class="value">$10,000</div></div>' +
    '<div class="dash-card highlight"><div class="label">Current Value</div><div class="value" style="color:' + (val>=10000?'var(--green)':'var(--red)') + '">$' + val.toFixed(2) + '</div></div>' +
    '<div class="dash-card"><div class="label">Total P&L</div><div class="value ' + (totalPnl>=0?'pnl-pos':'pnl-neg') + '">' + (totalPnl>=0?'+':'') + '$' + totalPnl.toFixed(2) + ' (' + (totalPnl>=0?'+':'') + totalPnlPct + '%)</div></div>' +
    '<div class="dash-card"><div class="label">Win Rate</div><div class="value">' + winRate + (winRate!=='\u2014'?'%':'') + '</div><div class="sub">' + wins + '/' + closedTrades.length + ' trades</div></div>' +
    '<div class="dash-card"><div class="label">Cash Balance</div><div class="value">$' + p.cashBalance.toFixed(2) + '</div></div>' +
    '<div class="dash-card"><div class="label">Open / Closed</div><div class="value">' + openTrades.length + ' / ' + closedTrades.length + '</div></div>';

  // Open positions
  if (openTrades.length === 0) {
    document.getElementById('openPositionsTable').innerHTML = '<div class="empty-state">No open positions. Use the Scanner to find opportunities!</div>';
  } else {
    var rows = openTrades.map(function(t) {
      var uPnl = (t.currentPrice - t.entryPrice) * t.shares;
      var uPnlPct = ((t.currentPrice - t.entryPrice) / t.entryPrice * 100).toFixed(1);
      var cls = uPnl >= 0 ? 'pnl-pos' : 'pnl-neg';
      var scannerLink = allOpportunities.find(function(o){return o.id === t.marketId;})
        ? ' <a href="#" onclick="event.preventDefault();switchTab(\'scanner\');openModal(\'' + t.marketId + '\')" style="font-size:11px">\u{1f50d}</a>' : '';
      return '<tr><td style="max-width:200px;overflow:hidden;text-overflow:ellipsis;white-space:nowrap" title="' + t.question.replace(/"/g,'&quot;') + '">' + t.question + scannerLink + '</td>' +
        '<td>' + t.direction.replace('BUY ','') + '</td>' +
        '<td>' + (t.entryPrice*100).toFixed(1) + '\u00a2 \u2192 ' + (t.currentPrice*100).toFixed(1) + '\u00a2</td>' +
        '<td class="' + cls + '">' + (uPnl>=0?'+':'') + '$' + uPnl.toFixed(2) + ' (' + (uPnl>=0?'+':'') + uPnlPct + '%)</td>' +
        '<td>' + formatTimeHeld(t.entryTime) + '</td>' +
        '<td><button class="close-pos-btn" onclick="closePosition(\'' + t.id + '\')">Close</button></td></tr>';
    }).join('');
    document.getElementById('openPositionsTable').innerHTML = '<table class="portfolio-table"><thead><tr><th>Market</th><th>Dir</th><th>Entry \u2192 Current</th><th>Unrealized P&L</th><th>Held</th><th></th></tr></thead><tbody>' + rows + '</tbody></table>';
  }

  // Closed trades
  if (closedTrades.length === 0) {
    document.getElementById('closedTradesTable').innerHTML = '<div class="empty-state">No closed trades yet.</div>';
  } else {
    var crows = closedTrades.slice().reverse().map(function(t) {
      var cls = t.pnl >= 0 ? 'pnl-pos' : 'pnl-neg';
      var pnlPct = ((t.exitPrice - t.entryPrice) / t.entryPrice * 100).toFixed(1);
      return '<tr><td style="max-width:200px;overflow:hidden;text-overflow:ellipsis;white-space:nowrap" title="' + t.question.replace(/"/g,'&quot;') + '">' + t.question + '</td>' +
        '<td>' + t.direction.replace('BUY ','') + '</td>' +
        '<td>' + (t.entryPrice*100).toFixed(1) + '\u00a2 \u2192 ' + (t.exitPrice*100).toFixed(1) + '\u00a2</td>' +
        '<td class="' + cls + '">' + (t.pnl>=0?'+':'') + '$' + t.pnl.toFixed(2) + ' (' + (t.pnl>=0?'+':'') + pnlPct + '%)</td>' +
        '<td>' + formatTimeHeld(t.entryTime, t.exitTime) + '</td>' +
        '<td><span class="reasoning-toggle" onclick="this.nextElementSibling.classList.toggle(\'open\')">\u{1f4ac} Why</span><div class="reasoning-expand">' + (t.reasoning||'No reasoning recorded.') + '</div></td></tr>';
    }).join('');
    document.getElementById('closedTradesTable').innerHTML = '<table class="portfolio-table"><thead><tr><th>Market</th><th>Dir</th><th>Entry \u2192 Exit</th><th>P&L</th><th>Held</th><th>Reasoning</th></tr></thead><tbody>' + crows + '</tbody></table>';
  }

  renderPnlChart();
  renderTradeLog();
  updateAutoStats();
}

function renderPnlChart() {
  var canvas = document.getElementById('pnlChart');
  if (!canvas) return;
  var ctx = canvas.getContext('2d');
  var wrap = canvas.parentElement;
  canvas.width = wrap.clientWidth - 40;
  canvas.height = wrap.clientHeight - 40;
  var W = canvas.width, H = canvas.height;
  ctx.clearRect(0, 0, W, H);

  var snaps = getSnapshots();
  if (snaps.length < 2) {
    ctx.fillStyle = '#555a70';
    ctx.font = '13px sans-serif';
    ctx.textAlign = 'center';
    ctx.fillText('Chart will appear after portfolio activity', W/2, H/2);
    return;
  }

  var values = snaps.map(function(s){return s.value;});
  var minV = Math.min.apply(null, values) * 0.995;
  var maxV = Math.max.apply(null, values) * 1.005;
  var range = maxV - minV || 1;
  var pad = 10;

  ctx.strokeStyle = '#1e2130'; ctx.lineWidth = 1;
  for (var i = 0; i <= 4; i++) {
    var y = pad + (H - 2*pad) * i / 4;
    ctx.beginPath(); ctx.moveTo(pad, y); ctx.lineTo(W-pad, y); ctx.stroke();
    ctx.fillStyle = '#555a70'; ctx.font = '10px sans-serif'; ctx.textAlign = 'left';
    ctx.fillText('$' + (maxV - (range * i / 4)).toFixed(0), pad, y - 3);
  }

  ctx.beginPath();
  for (var i = 0; i < values.length; i++) {
    var x = pad + (W - 2*pad) * i / (values.length - 1);
    var y = pad + (H - 2*pad) * (1 - (values[i] - minV) / range);
    if (i === 0) ctx.moveTo(x, y); else ctx.lineTo(x, y);
  }
  var lastVal = values[values.length - 1];
  ctx.strokeStyle = lastVal >= 10000 ? '#00d68f' : '#ff4d6a';
  ctx.lineWidth = 2; ctx.stroke();

  ctx.lineTo(pad + (W - 2*pad), H - pad);
  ctx.lineTo(pad, H - pad);
  ctx.closePath();
  ctx.fillStyle = lastVal >= 10000 ? 'rgba(0,214,143,0.08)' : 'rgba(255,77,106,0.08)';
  ctx.fill();

  var baseY = pad + (H - 2*pad) * (1 - (10000 - minV) / range);
  if (baseY > pad && baseY < H - pad) {
    ctx.setLineDash([4,4]); ctx.strokeStyle = '#555a70'; ctx.lineWidth = 1;
    ctx.beginPath(); ctx.moveTo(pad, baseY); ctx.lineTo(W-pad, baseY); ctx.stroke();
    ctx.setLineDash([]); ctx.fillStyle = '#555a70'; ctx.font = '10px sans-serif';
    ctx.fillText('$10,000', W - pad - 45, baseY - 4);
  }
}

// Hook: scanner card render (autonomous mode - no manual trade buttons on cards)
var _origRenderGrid = renderGrid;
renderGrid = function() {
  _origRenderGrid();
};

// Hook: add Mock Trade button to modal
var _origOpenModal = openModal;
openModal = function(id) {
  _origOpenModal(id);
  var o = allOpportunities.find(function(x){return x.id === id;});
  if (!o) return;
  var modalEl = document.getElementById('modal');
  var link = modalEl.querySelector('.modal-link');
  if (link && !modalEl.querySelector('.modal-mock-trade')) {
    var btn = document.createElement('button');
    btn.className = 'btn modal-mock-trade';
    btn.style.cssText = 'margin-left:12px;padding:10px 18px;background:var(--green);border-color:var(--green);color:#000;font-weight:600;font-size:14px;border-radius:8px;cursor:pointer';
    btn.textContent = '\u{1f4dd} Mock Trade';
    btn.onclick = function() {
      closeModal();
      openTradeForm({
        marketId: o.id, question: o.question, direction: o.direction,
        entryPrice: o.entryPrice, size: 100,
        reasoning: o.deepAnalysis ? o.deepAnalysis.whyEdge.slice(0,200) : 'Model edge: ' + (o.returnPct*100).toFixed(1) + '% ROI, ' + o.confidence + ' confidence'
      });
    };
    link.parentNode.insertBefore(btn, link.nextSibling);
  }
};

// ============================================
// AUTONOMOUS AUTO-TRADER
// ============================================

function logTradeAction(action, trade, reason) {
  const log = JSON.parse(localStorage.getItem('pm_trade_log') || '[]');
  log.unshift({
    time: new Date().toISOString(),
    action,
    market: trade.question,
    direction: trade.direction,
    price: action === 'OPEN' ? trade.entryPrice : trade.exitPrice,
    shares: trade.shares,
    reason
  });
  if (log.length > 200) log.length = 200;
  localStorage.setItem('pm_trade_log', JSON.stringify(log));
}

function autoTrader() {
  const portfolio = getPortfolio();
  const ops = allOpportunities;
  if (!ops || ops.length === 0) return;

  // === EXIT LOGIC ===
  for (const trade of portfolio.trades.filter(t => t.status === 'open')) {
    const market = ops.find(o => o.id === trade.marketId);
    if (!market) continue;

    const currentPrice = trade.direction === 'BUY YES' ? market.marketPrice : (1 - market.marketPrice);
    const pnlPct = (currentPrice - trade.entryPrice) / trade.entryPrice;
    const hoursHeld = (Date.now() - new Date(trade.entryTime).getTime()) / 3600000;

    let shouldClose = false;
    let closeReason = '';

    if (pnlPct > 0.20) {
      shouldClose = true;
      closeReason = `Take profit: +${(pnlPct*100).toFixed(1)}% gain captured`;
    } else if (trade.direction === 'BUY YES' && market.marketPrice >= market.modelEstimate) {
      shouldClose = true;
      closeReason = `Edge captured: market ${(market.marketPrice*100).toFixed(1)}¬¢ reached model ${(market.modelEstimate*100).toFixed(1)}¬¢`;
    } else if (trade.direction === 'BUY NO' && market.marketPrice <= (1 - market.modelEstimate)) {
      shouldClose = true;
      closeReason = `Edge captured: market moved to model estimate`;
    } else if (pnlPct < -0.30) {
      shouldClose = true;
      closeReason = `Stop loss: ${(pnlPct*100).toFixed(1)}% ‚Äî cutting losses`;
    } else if (hoursHeld > 48 && market.returnPct < 0.05) {
      shouldClose = true;
      closeReason = `Stale position: held ${Math.round(hoursHeld)}h, edge shrunk to ${(market.returnPct*100).toFixed(1)}%`;
    } else if (market.eventWindowPassed || market.daysLeft === 0) {
      shouldClose = true;
      closeReason = `Market resolving/resolved ‚Äî exiting`;
    }

    if (shouldClose) {
      trade.exitPrice = currentPrice;
      trade.exitTime = new Date().toISOString();
      trade.pnl = (currentPrice - trade.entryPrice) * trade.shares;
      trade.status = 'closed';
      trade.closeReason = closeReason;
      portfolio.cashBalance += currentPrice * trade.shares;
      logTradeAction('CLOSE', trade, closeReason);
    }
  }

  // === ENTRY LOGIC ===
  const openMarketIds = new Set(portfolio.trades.filter(t => t.status === 'open').map(t => t.marketId));
  let openCount = portfolio.trades.filter(t => t.status === 'open').length;
  const maxOpenPositions = 10;
  const positionSize = 100;

  const candidates = ops
    .filter(o => !openMarketIds.has(o.id))
    .filter(o => o.returnPct > 0.25)
    .filter(o => o.confidence !== 'low' || o.returnPct > 0.5)
    .filter(o => o.liquidity > 30000)
    .filter(o => !o.eventWindowPassed)
    .filter(o => o.daysLeft > 0)
    .sort((a, b) => b.returnPct - a.returnPct);

  for (const opp of candidates) {
    if (openCount >= maxOpenPositions) break;
    if (portfolio.cashBalance < positionSize) break;

    const entryPrice = opp.direction === 'BUY YES' ? opp.marketPrice : (1 - opp.marketPrice);
    if (entryPrice <= 0 || entryPrice >= 1) continue;

    const shares = Math.floor(positionSize / entryPrice);
    if (shares <= 0) continue;

    const trade = {
      id: crypto.randomUUID ? crypto.randomUUID() : Date.now().toString(36) + Math.random().toString(36).slice(2),
      marketId: opp.id,
      question: opp.question,
      direction: opp.direction,
      entryPrice: entryPrice,
      entryTime: new Date().toISOString(),
      shares: shares,
      currentPrice: entryPrice,
      status: 'open',
      exitPrice: null,
      exitTime: null,
      pnl: null,
      reasoning: `Auto-trade: ${(opp.returnPct*100).toFixed(0)}% ROI, ${opp.confidence} confidence, $${formatNum(opp.liquidity)} liquidity. Model: ${(opp.modelEstimate*100).toFixed(1)}¬¢ vs market ${(opp.marketPrice*100).toFixed(1)}¬¢.`,
      modelEstimate: opp.modelEstimate
    };

    portfolio.trades.push(trade);
    portfolio.cashBalance -= entryPrice * shares;
    openCount++;
    logTradeAction('OPEN', trade, `ROI: ${(opp.returnPct*100).toFixed(0)}%, Confidence: ${opp.confidence}`);
  }

  portfolio.portfolioValue = calcPortfolioValue(portfolio);
  savePortfolio(portfolio);
  saveSnapshot(portfolio.portfolioValue);
  updateAutoStats();
  if (document.getElementById('tab-portfolio').classList.contains('active')) renderPortfolio();
}

function updateAutoStats() {
  const p = getPortfolio();
  const openCount = p.trades.filter(t => t.status === 'open').length;
  const val = calcPortfolioValue(p);
  const pnl = val - 10000;
  const sign = pnl >= 0 ? '+' : '';
  const color = pnl >= 0 ? 'var(--green)' : 'var(--red)';
  const el = document.getElementById('autoStats');
  if (el) el.innerHTML = `${openCount} open positions | <span style="color:${color}">${sign}$${pnl.toFixed(2)} P&L</span>`;
  // Also update header badge
  const hdr = document.getElementById('autoTradingBadge');
  if (hdr) hdr.innerHTML = `ü§ñ <span style="color:var(--green)">Auto</span> | ${openCount} pos | <span style="color:${color}">${sign}$${pnl.toFixed(0)}</span>`;
}

function renderTradeLog() {
  const log = JSON.parse(localStorage.getItem('pm_trade_log') || '[]');
  const el = document.getElementById('tradeLogSection');
  if (!el) return;
  if (log.length === 0) {
    el.innerHTML = '<div class="empty-state">No autonomous trades yet. The auto-trader runs every 60s.</div>';
    return;
  }
  const rows = log.slice(0, 50).map(function(entry) {
    const time = new Date(entry.time).toLocaleString();
    const actionColor = entry.action === 'OPEN' ? 'var(--green)' : 'var(--red)';
    const actionIcon = entry.action === 'OPEN' ? 'üü¢' : 'üî¥';
    const mkt = entry.market.length > 60 ? entry.market.slice(0,57) + '...' : entry.market;
    const price = entry.price ? (entry.price * 100).toFixed(1) + '¬¢' : '‚Äî';
    return '<tr>' +
      '<td style="font-size:11px;white-space:nowrap;color:var(--text-dim)">' + time + '</td>' +
      '<td><span style="color:' + actionColor + ';font-weight:700">' + actionIcon + ' ' + entry.action + '</span></td>' +
      '<td style="max-width:200px;overflow:hidden;text-overflow:ellipsis;white-space:nowrap" title="' + (entry.market||'').replace(/"/g,'&quot;') + '">' + mkt + '</td>' +
      '<td>' + (entry.direction||'').replace('BUY ','') + '</td>' +
      '<td>' + price + '</td>' +
      '<td style="font-size:12px;color:var(--text-dim);max-width:250px;overflow:hidden;text-overflow:ellipsis;white-space:nowrap" title="' + (entry.reason||'').replace(/"/g,'&quot;') + '">' + (entry.reason||'') + '</td>' +
      '</tr>';
  }).join('');
  el.innerHTML = '<table class="portfolio-table"><thead><tr><th>Time</th><th>Action</th><th>Market</th><th>Dir</th><th>Price</th><th>Reason</th></tr></thead><tbody>' + rows + '</tbody></table>';
}

// Hook: update portfolio prices on each fetch + run autoTrader
var _origFetchMarkets = fetchMarkets;
fetchMarkets = async function() {
  await _origFetchMarkets();
  updateOpenPrices();
  autoTrader();
  updatePortfolioSummaryBar();
};

// ============================================
// AUTONOMOUS TRADER
// ============================================

var TRADE_LOG_KEY = 'polymarket_trade_log';

function getTradeLog() {
  var raw = localStorage.getItem(TRADE_LOG_KEY);
  return raw ? JSON.parse(raw) : [];
}

function addTradeLog(entry) {
  var log = getTradeLog();
  log.push({ time: new Date().toISOString(), message: entry });
  if (log.length > 200) log.splice(0, log.length - 200);
  localStorage.setItem(TRADE_LOG_KEY, JSON.stringify(log));
}

function autoTrader() {
  if (!allOpportunities || allOpportunities.length === 0) return;

  var p = getPortfolio();
  var openTrades = p.trades.filter(function(t) { return t.status === 'open'; });
  var openMarketIds = new Set(openTrades.map(function(t) { return t.marketId; }));
  var acted = false;

  // === EXIT RULES: check open positions ===
  for (var i = 0; i < openTrades.length; i++) {
    var t = openTrades[i];
    var opp = allOpportunities.find(function(o) { return o.id === t.marketId; });
    var currentPrice = t.currentPrice;
    var entryPrice = t.entryPrice;
    var positionPnlPct = (currentPrice - entryPrice) / entryPrice;
    var hoursHeld = (Date.now() - new Date(t.entryTime).getTime()) / 3600000;
    var reason = null;

    // (a) Edge captured: current price moved past model estimate
    if (opp) {
      var targetPrice = t.direction === 'BUY YES' ? opp.modelEstimate : (1 - opp.modelEstimate);
      if (currentPrice >= targetPrice && positionPnlPct > 0) {
        reason = 'Edge captured \u2014 price reached model estimate (' + (currentPrice*100).toFixed(1) + '\u00a2 >= ' + (targetPrice*100).toFixed(1) + '\u00a2). P&L: ' + (positionPnlPct>=0?'+':'') + (positionPnlPct*100).toFixed(1) + '%';
      }
    }

    // (b) Market resolved (price near 0 or 1)
    if (!reason && (currentPrice > 0.95 || currentPrice < 0.05)) {
      reason = 'Market appears resolved (price at ' + (currentPrice*100).toFixed(1) + '\u00a2). Taking profit/loss.';
    }

    // (c) Stale trade: 24h+ and edge shrunk below 5%
    if (!reason && hoursHeld >= 24 && opp) {
      var currentEdge = Math.abs(opp.modelEstimate - opp.marketPrice);
      var currentROI = opp.entryPrice > 0 ? currentEdge / opp.entryPrice : 0;
      if (currentROI < 0.05) {
        reason = 'Held 24h+ and edge shrunk to ' + (currentROI*100).toFixed(1) + '% ROI (below 5% threshold). Closing stale position.';
      }
    }

    // (d) Stop-loss: down > 30%
    if (!reason && positionPnlPct < -0.30) {
      reason = 'Stop-loss triggered \u2014 position down ' + (positionPnlPct*100).toFixed(1) + '% (threshold: -30%)';
    }

    if (reason) {
      var pnlBefore = (currentPrice - entryPrice) * t.shares;
      t.exitPrice = currentPrice;
      t.exitTime = new Date().toISOString();
      t.pnl = pnlBefore;
      t.status = 'closed';
      p.cashBalance += t.shares * currentPrice;
      acted = true;
      addTradeLog('\u{1f534} CLOSED ' + t.direction + ' on "' + t.question.slice(0,60) + '" at ' + (currentPrice*100).toFixed(1) + '\u00a2 \u2014 ' + reason + ' | P&L: ' + (pnlBefore>=0?'+':'') + '$' + pnlBefore.toFixed(2));
    }
  }

  // === ENTRY RULES: scan top opportunities ===
  var candidates = allOpportunities.filter(function(o) {
    return o.returnPct > 0.30 &&
           (o.confidence === 'medium' || o.confidence === 'high') &&
           o.liquidity > 50000 &&
           !openMarketIds.has(o.id) &&
           !o.eventWindowPassed;
  }).sort(function(a,b) { return b.returnPct - a.returnPct; }).slice(0, 10);

  for (var j = 0; j < candidates.length; j++) {
    var c = candidates[j];
    if (p.cashBalance < 100) break; // need at least $100
    // Don't open more than 10 simultaneous positions
    var currentOpen = p.trades.filter(function(t){return t.status==='open';}).length;
    if (currentOpen >= 10) break;

    var shares = 100 / c.entryPrice;
    p.trades.push({
      id: generateTradeId(),
      marketId: c.id,
      question: c.question,
      direction: c.direction,
      entryPrice: c.entryPrice,
      entryTime: new Date().toISOString(),
      shares: shares,
      currentPrice: c.entryPrice,
      status: 'open',
      exitPrice: null,
      exitTime: null,
      pnl: null,
      reasoning: 'Auto-entry: ' + (c.returnPct*100).toFixed(1) + '% ROI, ' + c.confidence + ' confidence, $' + formatNum(c.liquidity) + ' liquidity. ' + (c.deepAnalysis ? c.deepAnalysis.whyEdge.slice(0,150) : '')
    });
    p.cashBalance -= 100;
    acted = true;
    openMarketIds.add(c.id);
    addTradeLog('\u{1f7e2} OPENED ' + c.direction + ' on "' + c.question.slice(0,60) + '" at ' + (c.entryPrice*100).toFixed(1) + '\u00a2 ($100) \u2014 ' + (c.returnPct*100).toFixed(1) + '% ROI, ' + c.confidence + ' confidence');
  }

  if (acted) {
    p.portfolioValue = calcPortfolioValue(p);
    savePortfolio(p);
    saveSnapshot(p.portfolioValue);
    if (document.getElementById('tab-portfolio').classList.contains('active')) renderPortfolio();
  }

  // Update auto stats
  updateAutoStats();
}

function updateAutoStats() {
  var p = getPortfolio();
  var openCount = p.trades.filter(function(t){return t.status==='open';}).length;
  var closedCount = p.trades.filter(function(t){return t.status==='closed';}).length;
  var val = calcPortfolioValue(p);
  var pnl = val - 10000;
  var el = document.getElementById('autoStats');
  if (el) el.innerHTML = '\u{1f4ca} ' + openCount + ' open | ' + closedCount + ' closed | P&L: <span style="color:' + (pnl>=0?'var(--green)':'var(--red)') + '">' + (pnl>=0?'+':'') + '$' + pnl.toFixed(2) + '</span>';
}

function renderTradeLog() {
  var log = getTradeLog();
  var el = document.getElementById('tradeLogSection');
  if (!el) return;
  if (log.length === 0) {
    el.innerHTML = '<div class="empty-state">No autonomous decisions yet. The bot will start trading on the next data refresh.</div>';
    return;
  }
  var html = '<div style="max-height:300px;overflow-y:auto;background:var(--bg);border-radius:10px;padding:12px;border:1px solid var(--border)">';
  for (var i = log.length - 1; i >= 0; i--) {
    var entry = log[i];
    var d = new Date(entry.time);
    var ts = d.toLocaleString();
    var isOpen = entry.message.indexOf('\u{1f7e2}') === 0;
    var color = isOpen ? 'var(--green)' : 'var(--red)';
    html += '<div style="padding:6px 0;border-bottom:1px solid var(--border);font-size:12px;line-height:1.5">';
    html += '<span style="color:var(--text-muted);margin-right:8px">' + ts + '</span>';
    html += '<span style="color:' + color + '">' + entry.message + '</span></div>';
  }
  html += '</div>';
  el.innerHTML = html;
}

// Patch renderPortfolio to also render trade log and auto stats
var _origRenderPortfolio = renderPortfolio;
renderPortfolio = function() {
  _origRenderPortfolio();
  renderTradeLog();
  updateAutoStats();
};

// Patch fetchMarkets to run autoTrader after each refresh
var _origFetchMarkets2 = fetchMarkets;
fetchMarkets = async function() {
  await _origFetchMarkets2();
  autoTrader();
};

// Remove the "+ New Trade" button label, replace with manual override
// (already handled in HTML)

// Init portfolio summary
updatePortfolioSummaryBar();

</script>
</body>
</html>
